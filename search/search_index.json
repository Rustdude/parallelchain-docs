{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the ParallelChain Mainnet Documentation","text":"<p>This documentation website aims to provide you with a comprehensive understanding of the ParallelChain Mainnet ecosystem, including its architecture, programming model, and tools.</p> <p>The content of this guide covers topics ranging from setting up your development environment to building, deploying and verifying smart contracts on the ParallelChain Mainnet network.</p> <p>In this guide, you will learn:</p> <ul> <li>Basics of ParallelChain Mainnet architecture and programming model</li> <li>Basic concepts and terms encountered in ParallelChain Mainnet</li> <li>How to use tools provided by ParallelChain, including <code>pchain-client</code>, <code>pchain-sdk</code> etc</li> <li>How to set up a development environment</li> <li>How to deploy smart contracts and interact with them using the command-line interface and SDK</li> </ul> <p>Whether you are a seasoned blockchain developer or just getting started with smart contract development, our Web Guide provides all the resources you need to start building on the ParallelChain Mainnet network.</p> <p>Let's get started!</p>","tags":["ParallelChain"]},{"location":"#contact-us","title":"Contact us","text":"<p>If you are interested in ParallelChain Mainnet, reach out on us from our Official Telegram Group or Discord channel. </p>","tags":["ParallelChain"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#account","title":"Account","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#block-header","title":"Block Header","text":"<ul> <li>Block</li> </ul>"},{"location":"tags/#cli","title":"CLI","text":"<ul> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> </ul>"},{"location":"tags/#call","title":"Call","text":"<ul> <li>Call Contract</li> </ul>"},{"location":"tags/#consensus","title":"Consensus","text":"<ul> <li>Consensus</li> </ul>"},{"location":"tags/#contract-methods","title":"Contract Methods","text":"<ul> <li>Contract Methods</li> </ul>"},{"location":"tags/#contract-publishing-service","title":"Contract Publishing Service","text":"<ul> <li>Contract Publishing Service</li> </ul>"},{"location":"tags/#cross-contract-call","title":"Cross Contract Call","text":"<ul> <li>Cross Contract Call</li> </ul>"},{"location":"tags/#cryptographic-functions","title":"Cryptographic Functions","text":"<ul> <li>Crypto</li> </ul>"},{"location":"tags/#delegator","title":"Delegator","text":"<ul> <li>Delegators</li> </ul>"},{"location":"tags/#eoa","title":"EOA","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#epoch","title":"Epoch","text":"<ul> <li>Epoch</li> </ul>"},{"location":"tags/#epoch-transition","title":"Epoch Transition","text":"<ul> <li>Epoch</li> </ul>"},{"location":"tags/#exit-status","title":"Exit Status","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#explorer","title":"Explorer","text":"<ul> <li>Explorer</li> </ul>"},{"location":"tags/#gray","title":"Gray","text":"<ul> <li>What is XPLL?</li> </ul>"},{"location":"tags/#log","title":"Log","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#mainnet","title":"Mainnet","text":"<ul> <li>What is ParallelChain?</li> <li>Why Build on ParallelChain?</li> </ul>"},{"location":"tags/#maxbasefeepergas","title":"MaxBaseFeePerGas","text":"<ul> <li>Mempool</li> </ul>"},{"location":"tags/#network-account","title":"Network Account","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#network-transaction","title":"Network Transaction","text":"<ul> <li>Staking</li> </ul>"},{"location":"tags/#nonce","title":"Nonce","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#prfc","title":"PRFC","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#parallelchain","title":"ParallelChain","text":"<ul> <li>Welcome to the ParallelChain Mainnet Documentation</li> <li>What is ParallelChain?</li> <li>Why Build on ParallelChain?</li> </ul>"},{"location":"tags/#parallelchain-mainnet","title":"ParallelChain Mainnet","text":"<ul> <li>Mainnet</li> </ul>"},{"location":"tags/#parallelchain-rpc-api","title":"ParallelChain RPC API","text":"<ul> <li>Block-related RPC</li> <li>Introduction</li> <li>State-related RPC</li> <li>Transaction-related RPC</li> </ul>"},{"location":"tags/#parallelchain-testnet","title":"ParallelChain Testnet","text":"<ul> <li>Testnet</li> </ul>"},{"location":"tags/#pool","title":"Pool","text":"<ul> <li>Delegators</li> <li>Validators</li> </ul>"},{"location":"tags/#receipt","title":"Receipt","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#requirements","title":"Requirements","text":"<ul> <li>Requirements</li> </ul>"},{"location":"tags/#running-nodes","title":"Running Nodes","text":"<ul> <li>Running a Node</li> </ul>"},{"location":"tags/#rust","title":"Rust","text":"<ul> <li>Develop Contract</li> <li>Install SDK</li> </ul>"},{"location":"tags/#smart-contract","title":"Smart Contract","text":"<ul> <li>PRFC</li> <li>Smart Contract</li> <li>Build Contract</li> <li>Call Contract</li> <li>Deploy Contract</li> <li>Develop Contract</li> <li>Install SDK</li> <li>Introduction</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Crypto</li> <li>Contract Methods</li> <li>Accessing Information About the Blockchain</li> <li>Staking in Contract</li> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#staking","title":"Staking","text":"<ul> <li>Staking</li> <li>Delegators</li> <li>FAQ</li> <li>How does staking work?</li> <li>Validators</li> <li>What is staking?</li> <li>Staking</li> <li>Staking in Contract</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#storage","title":"Storage","text":"<ul> <li>Storage</li> </ul>"},{"location":"tags/#txpll","title":"TXPLL","text":"<ul> <li>What is XPLL?</li> </ul>"},{"location":"tags/#testnet-4","title":"Testnet 4","text":"<ul> <li>Testnet</li> </ul>"},{"location":"tags/#token-standard","title":"Token Standard","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Introduction</li> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> <li>Block-related RPC</li> <li>Introduction</li> <li>State-related RPC</li> <li>Transaction-related RPC</li> </ul>"},{"location":"tags/#transaction","title":"Transaction","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#validator","title":"Validator","text":"<ul> <li>Validators</li> </ul>"},{"location":"tags/#wallet","title":"Wallet","text":"<ul> <li>Wallet</li> </ul>"},{"location":"tags/#world-state","title":"World State","text":"<ul> <li>Storage</li> <li>Contract Storage</li> </ul>"},{"location":"tags/#xpll","title":"XPLL","text":"<ul> <li>Wallet</li> <li>How to get XPLL?</li> <li>What is XPLL?</li> </ul>"},{"location":"tags/#account_1","title":"account","text":"<ul> <li>Create Account</li> </ul>"},{"location":"tags/#explorer_1","title":"explorer","text":"<ul> <li>Prepare Environment</li> <li>Prepare Environment</li> </ul>"},{"location":"tags/#faucet","title":"faucet","text":"<ul> <li>Create Account</li> </ul>"},{"location":"tags/#gas","title":"gas","text":"<ul> <li>Gas</li> </ul>"},{"location":"tags/#hotstuffrs","title":"hotstuff.rs","text":"<ul> <li>Consensus</li> </ul>"},{"location":"tags/#internal-transaction","title":"internal transaction","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#mainnet_1","title":"mainnet","text":"<ul> <li>Create Account</li> <li>Prepare Environment</li> <li>Transfer Tokens</li> <li>Prepare Environment</li> <li>Transferring Balance</li> </ul>"},{"location":"tags/#mempool","title":"mempool","text":"<ul> <li>Mempool</li> </ul>"},{"location":"tags/#parallelchain-sdk","title":"parallelchain sdk","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#pchain-cli-rust","title":"pchain-cli-rust","text":"<ul> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> </ul>"},{"location":"tags/#pchain-client","title":"pchain-client","text":"<ul> <li>Create Account</li> <li>Installation</li> <li>Prepare Environment</li> <li>Staking</li> <li>Transfer Tokens</li> <li>Call Contract</li> <li>Deploy Contract</li> </ul>"},{"location":"tags/#pchain-compile","title":"pchain-compile","text":"<ul> <li>Contract Publishing Service</li> <li>Build Contract</li> </ul>"},{"location":"tags/#pchain-sdk","title":"pchain-sdk","text":"<ul> <li>Build Contract</li> <li>Develop Contract</li> <li>Install SDK</li> <li>Introduction</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Crypto</li> <li>Contract Methods</li> <li>Accessing Information About the Blockchain</li> <li>Staking in Contract</li> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#smart-contract_1","title":"smart contract","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#testnet","title":"testnet","text":"<ul> <li>Prepare Environment</li> <li>Transfer Tokens</li> <li>Prepare Environment</li> </ul>"},{"location":"tags/#testnet-4_1","title":"testnet 4","text":"<ul> <li>Create Account</li> <li>Transferring Balance</li> </ul>"},{"location":"tags/#transaction_1","title":"transaction","text":"<ul> <li>Accessing Information About the Blockchain</li> </ul>"},{"location":"tags/#tutorial","title":"tutorial","text":"<ul> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"},{"location":"concepts/PRFC/","title":"ParallelChain Request for Comments (PRFC)","text":"<p>PRFC (ParallelChain Request for Comments) defines application layer standards which specifies common interface of ParallelChain Smart Contract and its state representation so that applications running on ParallelChain can interact with for a well-defined purpose.</p> <p>The number suffix is identified as each standard\u2019s unique ID. At the time of writing, there have been 3 PRFCs proposed: PRFC1 defines a standard interface for fungible tokens, and PRFC2 for non-fungible tokens (similar meanings as ERC20 and ERC721 in Ethereum).</p> <p>You can find all PRFCs in this GitHub repository: https://github.com/parallelchain-io/prfcs. Please feel free to leave your comments or submit proposals on the Issues page.</p>","tags":["PRFC","Smart Contract","Token Standard"]},{"location":"concepts/account/","title":"Accounts","text":"<p>Account is the basic identity of an agent on the blockchain. An account is identified by its address. </p> <p>In Parallelchain Mainnet, accounts are divided into two types:</p> <ul> <li>Externally Owned Accounts (EOA): The address of an EOA is the public key of the keypair that is compatible with <code>ed25519_dalek</code>.</li> <li>Contract Accounts: A contract account is created from contract deployment. The address is the hash of the concatenation of a contract's bytecode and the nonce of the EOA that deploys the contract. </li> </ul> <p>Elements inside an account include:</p> <ul> <li>Nonce: The number of transactions made to the blockchain under this account.</li> <li>Balance: The balance of the account.</li> </ul> <p>The followings are elements that only apply to Contract Accounts:</p> <ul> <li>Contract Code: The binary of the contract that was deployed to the blockchain (applies to Contract Accounts).</li> <li>CBI Version: The version of the Contract Binary Interface.</li> <li>Storage Hash: The 32-byte SHA256 root hash of its Storage Trie. This is empty for an External.</li> </ul> <p>Notes:  These accounts cannot be distinguished from each other just by looking at the address format.</p> <p>A Network Account is a single identified network-wide account that maintains the state of ParallelChain Mainnet. This account is not associated with Ed25519 material. The network-significant data that the Network Account stores are composed of various fields:</p> <ul> <li>Previous Validator Set: The set of pools that form the validator set in the previous epoch. The stake in this validator set is locked until the next epoch.</li> <li>Current Validator Set: The set of pools that form the validator set in the current epoch.</li> <li>Next Validator Set: The limited-size pools with the largest powers. These will become the validator set in the next epoch.</li> <li>Pools: The set of pools that are accepting stakes and currently competing to become part of the next validator set.</li> <li>Deposits: The locked balance used to determine the amount of stake that can be contributed to a pool.</li> <li>Current Epoch: The current epoch number.</li> </ul>","tags":["Account","EOA","Network Account"]},{"location":"concepts/block/","title":"Block","text":"<p>Block is a data structure that describes and authorizes the execution of a batch of transactions (state transitions) on the blockchain.</p> <p>Elements inside a block include:</p> <ul> <li><code>Hash</code> - the unique identifier for the block</li> <li><code>Height</code> - a number that represents the position of the block on the blockchain</li> <li><code>Justify</code> - a certificate that proves the block was authorized by the network</li> </ul> <ul> <li><code>Chain ID</code> - a number that identifies a particular Parallelchain Mainnet-based blockchain</li> <li><code>Proposer</code> - the public address of the block producer</li> <li><code>Timestamp</code> - the time the block was created, measured in seconds since 1970-01-01</li> <li><code>Base Fee Per Gas</code> - the minimum number of grays that a transaction must pay for every gas used to be included in the block</li> <li><code>Gas Used</code> - the amount of gas used in a block, which is the total sum of the gas used in executing the included transactions</li> <li><code>Transactions Hash</code> - the root hash of the Merkle Tree that contains the transactions included in the block</li> <li><code>Receipt Hash</code> - the root hash of the Merkle Tree that contains the execution results of the transactions included in the block</li> <li><code>State Hash</code> - the root hash of the Merkle Tree that represents the current world state</li> <li><code>Log Bloom</code> - a 256-byte block-level Bloom Filter that combines all the Bloom Filters of each Log topic from the block's receipts</li> <li><code>Transactions</code> - the transactions that are included in the block</li> <li><code>Receipts</code> - the execution results of the transactions that are included in the block</li> </ul> <p>A block is a fundamental data structure in a blockchain system that serves as a container for a batch of transactions. It plays a critical role in maintaining the integrity and immutability of the blockchain.</p> <p>Each block contains a unique identifier known as the <code>block hash</code>, which is calculated based on the contents of the block. The block hash acts as a fingerprint for the block, making it tamper-evident. Any change to the block's contents would alter its hash, making it easily detectable by network participants.</p> <p>The block header contains important metadata about the block, including the block's <code>height</code>, <code>timestamp</code>, and the <code>address of the block producer</code>, among others. It also includes Merkle tree root hashes for transactions, receipts, and the current state of the blockchain.</p> <p>Transactions contained within the block are executed by the blockchain system, with the results recorded in <code>receipts</code>. These receipts contain information about the execution status of each transaction and are stored in a Merkle tree, with the root hash included in the block header.</p> <p>In addition to transactions and receipts, the block also contains a Bloom filter, which is a probabilistic data structure used to efficiently query logs associated with the transactions contained in the block.</p> <p>Overall, block is an essential component of a blockchain system, providing a secure and reliable means of recording and validating transactions while ensuring the immutability and integrity of the blockchain.</p>","tags":["Block Header"]},{"location":"concepts/consensus/","title":"HotStuff-rs","text":"<p>HotStuff-rs is a Rust Programming Language implementation of the HotStuff consensus protocol. It offers:</p> <ol> <li>Guaranteed Safety and Liveness in the face of up to 1/3rd of Voting Power being Byzantine at any given moment,</li> <li>A small API (<code>Executor</code>) for plugging in state machine-based applications like blockchains, and</li> <li>Well-documented, 'obviously correct' source code, designed for easy analysis and extension.</li> </ol> <p>A Rust Programming Language library for Byzantine Fault Tolerant state machine replication, intended for production  systems. </p> <p>HotStuff-rs implements a variant of the HotStuff consensus protocol, but with extensions like block-sync and dynamic validator sets that make this library suited for real-world use cases (and not just research systems). Some desirable properties that HotStuff-rs has are:</p> <ol> <li>Provable Safety in the face of up to 1/3rd of voting power being Byzantine at any given moment.</li> <li>Optimal Performance: consensus in (amortized) 1 round trip time.</li> <li>Simplicity: A small API (App) for plugging in arbitrary stateful applications.</li> <li>Modularity: pluggable networking, state persistence, and view-synchronization mechanism.</li> <li>Dynamic Validator Sets that can update without any downtime based on state updates: a must for PoS blockchain     applications.</li> <li>Batteries included: comes with a block-sync protocol and (coming soon) default implementations for networking,    state, and pacemaker: you write the app, and we handle the replication.</li> </ol>","tags":["Consensus","hotstuff.rs"]},{"location":"concepts/consensus/#terminology","title":"Terminology","text":"<ul> <li>App: user code which implements the App trait. This can be any business logic that can be expressed   as a deterministic state machine, i.e., a pure function of kind: <code>(Blockchain, App State, Validator Set, Block) -&gt;   (Next Blockchain, Next App State, Next Validator Set)</code>.</li> <li>Replica: a public-key-identified process that hosts an implementation of the HotStuff-rs protocol, e.g., this   library. There are two kinds of replicas: validators, and listeners. </li> <li>Blockchain: a growing sequence of Blocks, which can be thought of as instructions to update a replica's App   State and Validator Set.</li> <li>App State: a key-value store that applications can use to store anything; two replicas with the same Blockchain   are guaranteed to have the same app state.</li> <li>Validator Set: the set of replicas who can vote in a consensus decision.</li> <li>Progress protocol: the protocol replicas use to create new blocks through consensus and grow the blockchain.</li> <li>Sync protocol: the protocol new or previously offline replicas use to quickly catch up to the head of the   blockchain.</li> </ul>","tags":["Consensus","hotstuff.rs"]},{"location":"concepts/consensus/#the-hotstuff-consensus-protocol","title":"The HotStuff Consensus Protocol","text":"<p>HotStuff works by building a 'BlockTree': a directed acyclic graph of Blocks. Block is a structure with a <code>data</code> field which applications are free to populate with arbitrary byte-arrays. In consensus algorithm literature, we typically talk of consensus algorithms as maintaining state machines that change their internal states in response to commands, hence the choice of terminology.</p> <p>HotStuff guarantees that committed Blocks are immutable. That is, they can never be un-committed as long as at least a supermajority of voting power faithfully executes the protocol. This guarantee enables applications to make hard-to-reverse actions with confidence. </p> <p></p> <p>A Block becomes committed the instant its third confirmation is written into the BlockTree. Confirmation for a Block <code>A</code> is another Block <code>B</code> such that there is a path between <code>B</code> to <code>A</code>.</p> <p>The choice of third confirmation to define commitment--as opposed to first or second--is not arbitrary. HotStuff's safety and liveness properties hinge upon this condition. If you want to understand why this is the case, you should read the paper. To summarize:</p> <ol> <li>Classic BFT consensus algorithms such as PBFT require only 2 confirmations for commitment, but this comes at the cost of expensive leader-replacement flows.</li> <li>Tendermint requires only 2 confirmations for commitment and has a simple leader-replacement flow, but needs an explicit 'wait-for-N seconds' step to guarantee liveness.</li> </ol> <p>HotStuff is the first consensus algorithm with a simple leader-replacement algorithm that does not have a 'wait-for-N seconds' step and thus can make progress as fast as network latency allows.</p>","tags":["Consensus","hotstuff.rs"]},{"location":"concepts/consensus/#getting-started","title":"Getting Started","text":"<p>If you're trying to learn about HotStuff-rs by reading the source code or Cargo docs, we recommend starting from the replica module. This is the entry point of user code into this library.</p>","tags":["Consensus","hotstuff.rs"]},{"location":"concepts/epoch/","title":"Epoch","text":"<p>Epoch is a protocol-defined period for measuring the performance of operators on the blockchain network. </p> <p>The primary purpose of epochs in a blockchain is to facilitate various network functionalities and maintain consensus among network participants by defining a common reference point, which could be utilized to validate transactions. During one epoch, there would be block creation and block addition to the blockchain.</p> <p>In the ParallelChain Mainnet ecosystem, an <code>epoch</code> is defined by a predetermined block height or the number of blocks added to the blockchain, which is 8640. When a specific block height is reached or another 8640 blocks are added to the blockchain, the blockchain network would move from the current epoch to the next. The epoch transition could trigger critical events:</p> <ul> <li> <p>Reward stakes in Current Validator Set</p> <ul> <li>Increase deposits of owner and operator</li> <li>Update stakes if auto-stake-rewards is enabled</li> </ul> </li> <li> <p>Replacing Previous Validator Set with Current Validator Set</p> </li> <li>Replacing Current Validator Set with Next Validator Set</li> <li>Returning Next Validator Set for the next leader selection</li> </ul> <p>Epoch transition ensures that only one set of validators is active on the blockchain network at any given time, which makes the information on the blockchain tamper-proof.</p>","tags":["Epoch","Epoch Transition"]},{"location":"concepts/explorer/","title":"ParallelChain Explorer","text":"","tags":["Explorer"]},{"location":"concepts/explorer/#what-is-parallelchain-explorer","title":"What is ParallelChain Explorer","text":"<p>ParallelChain Explorer is a web-based tool integrated with the ParallelChain Mainnet ecosystem, which allows users to visualize and interact with the Mainnet. By using the explorer, users can search for real-time and historical information about the blockchain. </p>","tags":["Explorer"]},{"location":"concepts/explorer/#parallelchain-explorer-features","title":"ParallelChain Explorer Features","text":"<ul> <li>Search and Navigation: Find specific blocks, transactions, and accounts easily by using block hash, transaction hash, and account address.</li> <li>Block Details: Explore details of specific blocks, including block height, timestamp, transaction information, etc.</li> <li>Transaction Details: Explore details of specific transactions, including signer/recipient account information, timestamp, consumed gas, etc.</li> <li>Account Details: Explore details of specific accounts, including nonce, contract count, transaction history, etc.</li> <li>Staking Details: Explore details of staking information for each pool, including operator, pool power, and commission rate, etc.</li> <li>Network Statistics: Gain insights into network-wide statistics, including gas consumption, block production time, reward issuance, etc.</li> <li>Wallet Extension: Seamlessly create an Xperience wallet account and make transactions.</li> </ul> <p>Check out our ParallelChain Explorer!</p>","tags":["Explorer"]},{"location":"concepts/gas/","title":"Gas","text":"<p>To use resources on ParallelChain Mainnet, transactions impost some cost for storage and execution. ParallelChain Mainnet implements gas units in terms of XPLL (i.e., 1 Gray equals 1 gas). This means the actual cost of gas used during transactions is dynamically balanced when the price of the token increases or decreases due to economic factors. Please see the section Base Fee Formula in ParallelChain Mainnet Protocol for details.</p>","tags":["gas"]},{"location":"concepts/gas/#gas","title":"Gas","text":"<p>Gas is a representation of the cost incurred by resources per transaction in the ParallelChain Mainnet ecosystem. Every transaction is assigned a cost through gas metering.</p> <p>There are different categories of gas cost in the ParallelChain Mainnet ecosystem:</p> <ul> <li>WASM opcode execution inside a contract call</li> <li>Reading and writing WASM memory from host functions inside a contract call</li> <li>Transaction-related data storage</li> <li>World state storage and access</li> <li>Cryptographic operations</li> </ul> <p>Details about gas can be found in ParallelChain Mainnet Protocol.</p>","tags":["gas"]},{"location":"concepts/gas/#how-are-gas-fees-calculated","title":"How are Gas Fees Calculated?","text":"<p>Gas Fee here refers to the amount that is paid with the account's balance for the gas consumed in transaction execution. It can be generalized by the following equation:</p> <pre><code>Gas Fee = Gas Consumption x (Base Fee Per Gas + Priority Fee Per Gas)\n</code></pre> <ul> <li><code>Gas Consumption</code> is the gas unit consumed during the transaction execution. </li> <li><code>Base Fee Per Gas</code> is the dynamically adjusted value that depends on the traffic of the network at the time of transaction execution.</li> <li><code>Priority Fee Per Gas</code> is the amount specified in the transaction by the signer, which is transferred to block producer, on per-gas basis.</li> </ul>","tags":["gas"]},{"location":"concepts/gas/#gas-estimation","title":"Gas Estimation","text":"<p>Transaction can fail for setting the Gas limit too low. There is no absolute answer to what gas limit should be specified. In general, the gas limit must be greater than Transaction Inclusion Cost and smaller than Block Gas Limit (500000000).</p> <p>The following table summaries on estimated gas consumption of different transaction commands:</p> Command Estimation Transfer 166,350 Deploy Contract size of contract bytecode * 2600 Call Contract Varies a lot depends on contract implementation Create Deposit 216,370 Topup Deposit 185,630 Set Deposit Setting 159,560 Withdraw Deposit 4,000,000 (varies a lot depends on the state of the pools) Stake 4,000,000 (varies a lot depends on the state of the pools) Unstake 4,000,000 (varies a lot depends on the state of the pools) <p>The above values are calulated by including the transaction inclusion cost (Assume one transaction with one command). It is estimated based on experiments in ParallelChain Mainnet version as of the date on 11-May-2023.</p>","tags":["gas"]},{"location":"concepts/mainnet/","title":"ParallelChain Mainnet","text":"","tags":["ParallelChain Mainnet"]},{"location":"concepts/mainnet/#what-is-mainnet","title":"What is Mainnet","text":"<p>ParallelChain Mainnet is a high-performance blockchain designed for enterprise-level use cases. It provides a platform for developers to build decentralized applications (dApps) with its efficient smart contract execution engine.</p> <p>It is designed to balance high performance and genuine decentralization. It is protected by the ParallelBFT consensus protocol, which adopts a sophisticated class-based node system to ensure fast and accountable consensus.</p> <p>For more information about the consensus protocol, please read the section Consensus.</p>","tags":["ParallelChain Mainnet"]},{"location":"concepts/mempool/","title":"Mempool","text":"","tags":["mempool","MaxBaseFeePerGas"]},{"location":"concepts/mempool/#what-is-mempool","title":"What is Mempool?","text":"<p>A mempool is a component of the blockchain network that keeps transactions that have not yet been added to a block. It can refer to two things:</p> <ul> <li>The mempool of validating nodes and fullnodes, which accepts pending transactions for future inclusion in a block. (Only validating nodes can create new blocks.)</li> <li>The set of not-yet-confirmed transactions that are stored in the individual mempools of nodes in the network. This set can vary between nodes due to network delays and partitions.</li> </ul>","tags":["mempool","MaxBaseFeePerGas"]},{"location":"concepts/mempool/#how-does-mempool-work","title":"How does Mempool Work?","text":"<p>When a transaction is submitted to the blockchain network, it is first sent to the mempool where it waits to be executed. The mempool acts like a queue, storing the pending transactions and arranging them to be executed by block producers. Transactions are prioritized based on how much the sender is willing to pay for network resources, which is indicated in a field called <code>Max Base Fee Per Gas</code> within the transaction. The higher the fee, the higher the priority of the transaction.</p>","tags":["mempool","MaxBaseFeePerGas"]},{"location":"concepts/mempool/#max-base-fee-per-gas-and-eip-1559-in-ethereum","title":"Max Base Fee Per Gas and EIP-1559 in Ethereum","text":"<p>The priority ranking method based on the <code>Max Base Fee Per Gas</code> is a crucial component of the EIP-1559 model for transaction processing in Ethereum.</p> <p>In the EIP-1559 model, each transaction specifies two fees: the <code>base fee</code> and the <code>priority fee</code>. The <code>base fee</code> is dynamically determined by the network based on the current demand for block space and adjusts itself to keep block utilization at a target level. The <code>priority fee</code> is the amount that the user is willing to pay in addition to the base fee to prioritize their transaction.</p> <p>When a transaction is submitted to the network, it is placed in the mempool, and the <code>priority fee</code> value of the transaction is used to rank it. Transactions with higher priority fees are placed higher in the mempool, making them more likely to be included in the next block. However, unlike the traditional method of simply sorting transactions by the fee amount, EIP-1559 allows for more efficient use of block space by dynamically adjusting the <code>base fee</code>, which incentivizes users to pay only what they need to get their transaction included. This helps to prevent congestion and ensures that transactions are processed in an efficient and timely manner.</p>","tags":["mempool","MaxBaseFeePerGas"]},{"location":"concepts/mempool/#base-fee-per-gas-in-parallelchain-mainnet","title":"Base Fee Per Gas in ParallelChain Mainnet","text":"<p>In ParallelChain Mainnet, the <code>base fee per gas</code> is calculated according to the Base fee formula. This is nearly identical to Ethereum's EIP-1559 and shares the same purpose: adjust the cost of a transaction based on how busy the network is.</p> <p>Note: Validator nodes in ParallelChain Mainnet provided at the initial Launch do not take <code>priority fee</code> into the ranking calculation.</p>","tags":["mempool","MaxBaseFeePerGas"]},{"location":"concepts/smartcontract/","title":"Smart Contract","text":"","tags":["Smart Contract"]},{"location":"concepts/smartcontract/#what-is-smart-contract","title":"What is Smart Contract?","text":"<p>A smart contract is a way to run computer programs on a decentralized network that is secure and fault-tolerant. With smart contracts, users can write code to support their most critical business applications, all on a global, decentralized network.</p> <p>To use smart contracts on ParallelChain Mainnet, developers can write a Contract Binary Interface (CBI) Subprotocol that is implemented using a WebAssembly (WASM) module. However, for most developers, it's easier to use the <code>pchain-sdk</code> types and macros to write a Contract in Rust, and then use the <code>pchain-compile</code> commands to compile the Rust source code into WASM bytecode.</p>","tags":["Smart Contract"]},{"location":"concepts/smartcontract/#smart-contract-programming-model","title":"Smart Contract Programming Model","text":"<p>The Smart Contract Programming Model is based on Object-Oriented Programming (OOP). In this model, a contract is like a <code>Rust</code> <code>struct</code> that controls access to persistent storage. Accounts can interact with contracts by submitting transactions that include a call command to invoke methods of the contract. These methods are sometimes called just \"methods\" for short.</p> <p>See section Smart Contract Development for more information of <code>pchain-sdk</code>.</p>","tags":["Smart Contract"]},{"location":"concepts/smartcontract/#why-rust-and-webassembly-wasm","title":"Why Rust and WebAssembly (WASM)?","text":"<p>Writing smart contracts in Rust and executing them as WebAssembly (WASM) bytecode on a blockchain has several benefits:</p> <ol> <li> <p>Efficiency and Security: Rust is a systems programming language that provides a balance between performance and safety. It is designed to prevent common programming errors such as null pointer dereferencing and buffer overflows, which can cause security vulnerabilities. Rust's ownership model and borrow checker also help prevent memory leaks and race conditions. When compiled to WASM, Rust code can run efficiently and securely on a blockchain.</p> </li> <li> <p>Interoperability: WASM is a binary format that can be executed in different environments, such as web browsers and servers. This means that smart contracts written in programming languages and compiled to WASM can be executed on the blockchain that supports the WASM execution context. This provides more options for developers to choose from and promotes interoperability between different blockchain ecosystems.</p> </li> <li> <p>Tooling and Ecosystem: Rust has a rich ecosystem of libraries and tools for building systems and applications. This includes the mentioned <code>pchain-sdk</code>, which provides types and macros for writing smart contracts in Rust for the ParallelChain Mainnet blockchain. Rust's cargo package manager also makes it easy to manage dependencies and build projects. By leveraging the Rust ecosystem, developers can build smart contracts faster and with less effort.</p> </li> <li> <p>Community Support: Rust has a growing community of developers and contributors who are passionate about the language and its ecosystem. This means that there are resources available for learning Rust and getting help when needed. It also means that the language and ecosystem are constantly evolving and improving.</p> </li> </ol> <p>Overall, writing smart contracts in Rust and executing them as WASM bytecode on a blockchain provides a secure, efficient, interoperability, and well-supported programming environment for developers.</p>","tags":["Smart Contract"]},{"location":"concepts/storage/","title":"Storage","text":"<p>Storage is a decentralized database to store all necessary information to maintain a node and support data query of the blockchain. Unlike traditional decentralized databases which split data into chunks on different peers, each node instead broadcast the transactions that it received to other peer nodes. Once other nodes receive the transactions, they would execute transactions, verify the changes and update their database locally.</p> <p>Elements inside storage include:</p> <ul> <li><code>Blocks</code> - the full history of blocks from genesis.</li> <li><code>World State</code> - a singular user-visible state maintained by the blockchain.</li> <li><code>System state</code> - system data for running the node.</li> </ul>","tags":["Storage","World State"]},{"location":"concepts/storage/#blocks","title":"Blocks","text":"<p>A block is a data structure in a blockchain system. Except for the first block (a.k.a genesis), each block contains the block hash of the previous block in the header. The whole chain of blocks is stored in the database and can be retrieved using block hash or block height easily.</p> <p>See section Block for more information.</p>","tags":["Storage","World State"]},{"location":"concepts/storage/#world-state","title":"World State","text":"<p>The world state is a singular user-visible state maintained by the blockchain stored inside a Merkle Patricia Trie (MPT). Each account is associated with some states, representing in the set of key-value pairs, and which can trigger state changes in specific ways.</p> <p>There are three kinds of accounts, and they differ in how they trigger state changes:</p> <ul> <li>Externally Owned Accounts, which trigger state changes by digitally signing transactions</li> <li>Contract Accounts, which trigger state changes when called according to the logic in its code.</li> <li>Network Accounts, which triggers state changes by the next epoch transaction.</li> </ul> <p>See section Account for more information about different types of accounts.</p>","tags":["Storage","World State"]},{"location":"concepts/storage/#system-state","title":"System State","text":"<p>The system state stores system-level information to sync and communicate with other nodes in the blockchain. This part is non-accessible to the public and triggers state changes by consensus protocol.</p>","tags":["Storage","World State"]},{"location":"concepts/testnet/","title":"ParallelChain Testnet","text":"","tags":["ParallelChain Testnet","Testnet 4"]},{"location":"concepts/testnet/#what-is-testnet","title":"What is Testnet","text":"<p>To ensure the new features in ParallelChain Mainnet have what it takes to survive decentralized deployment, they must first be battle-tested. This is where ParallelChain Testnet comes into play by allowing developers, or simply users, to develop and run smart contracts or transactions on ParallelChain and experiment with the blockchain, at no cost.</p> <p>The current testnet iteration delivers on Byzantine Fault Tolerant (BFT) consensus, the cornerstone of security in ParallelChain's proof-of-stake network. Besides this, Testnet 4 delivers big leaps in the contract SDK and developer experience, as well as a web Wallet. Both Mainnet and Testnet are accessible through Explorer.</p>","tags":["ParallelChain Testnet","Testnet 4"]},{"location":"concepts/transaction/","title":"Transaction, Command and Receipt","text":"","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#command","title":"Command","text":"<p>A command is a useful operation that Parallelchain allows the user to do. A sequence of commands can be inserted into a transaction to be carried out. There are currently 13 different kinds of commands, each corresponding to a variant of the command enum type. These are further divided into three categories: account commands, staking commands, and protocol commands. Most commands take inputs, which are part of the command type as the fields of its corresponding variant.</p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#account-commands","title":"Account commands","text":"","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#transfer","title":"Transfer","text":"Name Input Description Transfer <li>Recipient (<code>PublicAddress</code>)</li> <li>Amount (<code>u64</code>)</li> Transfer an amount from the signer's balance to the recipient's balance. Deploy <li>Contract (<code>Vec&lt;u8&gt;</code>)</li> <li>CBI version (<code>u32</code>)</li> Deploy a contract that implements a given CBI version. Call <li>Target (<code>PublicAddress</code>)</li> <li>method (<code>String</code>)</li> <li>arguments (<code>Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;</code>)</li> <li>amount (<code>Option&lt;u64&gt;</code>)</li> Call a contract method with given arguments, optionally transferring some tokens.","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#staking-commands","title":"Staking commands","text":"Name Input Description Create pool <li>Commission rate (<code>u8</code>)</li> Create a new pool with the signer as the operator which charges a given commission rate on the validator rewards of delegated stakes Set pool settings <li>Commission rate (<code>u8</code>)</li> Set the commission rate of an existing pool, operated by the signer. Delete pool <li>None</li> Delete an existing pool, as well as all of its existing stakes. Create Deposit <li>Operator (<code>PublicAddress</code>)</li> <li>Balance (<code>u64</code>)</li> <li>Auto stake rewards (<code>bool</code>)</li> Create a deposit that targets a given operator, with the given balance, and stake the validator rewards that it receives optionally. Set deposit settings <li>Operator (<code>PublicAddress</code>)</li> <li>Auto stake rewards? (<code>bool</code>)</li> Set whether a given deposit automatically stakes validator rewards. Top up deposit <li>Operator (<code>PublicAddress</code>)</li> <li>Balance (<code>u64</code>)</li> Transfer more tokens into an existing deposit. Withdraw Deposit <li>Operator (<code>PublicAdddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to withdraw a given amount from a deposit into the signer's balance. Stake <li>Operator (<code>PublicAddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to stake a given amount from a deposit. Unstake <li>Operator (<code>PublicAddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to reduce a deposit's stake by a given amount. <p>Notes: </p> <p>The actual amount of tokens that could be withdrawn, staked, or unstaked by the final three kinds of commands depends on timing and order, factors that users do not have precise control over. For example, the number of tokens that can be withdrawn from a deposit can change significantly between epochs as the deposit's bonded balance decreases, or increases.</p> <p>Therefore, these commands accept as input a \"max amount\" instead of a precise amount. These commands try to withdraw, stake, or unstake as close to the maximum amount as possible, and inform the precise amount in its return value.</p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#protocol-commands","title":"Protocol commands","text":"Name Input Description Next epoch None Reward the current epoch's validators, and confirm the next epoch's validator set.","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#transaction","title":"Transaction","text":"<p>A transaction is a digitally signed instruction that tells the Mainnet state machine to execute a sequence of commands. </p> <p>A transaction has the following fields:</p> <ul> <li><code>Signer</code>: the public address of the external-owned account that signed this transaction.</li> <li><code>Nonce</code>: the number of transactions signed by the signer that has been included on the blockchain before this transaction. This ensures that all of the signer\u2019s transactions are included in the blockchain in an expected order and prevents the same transaction from being included in multiple blocks.</li> <li><code>Commands</code>: a sequence of Commands to be executed in a transaction.</li> <li><code>Gas Limit</code>: the maximum number of gas units that should be used in executing this transaction.</li> <li><code>Max Base Fee per Gas</code>: the maximum number of grays that the signer is willing to burn for a gas unit used in this transaction.</li> <li><code>Priority Fee per Gas</code>: the number of grays that the signer is willing to pay the block proposer for including this transaction in a block.</li> <li><code>Signature</code>: the signature formed by signing over content in this transaction using the signer\u2019s private key.</li> <li><code>Hash</code>: the cryptographic hash of the signature.</li> </ul>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/transaction/#receipt-and-logs","title":"Receipt and Logs","text":"<p>A receipt is produced upon execution of each transaction. It consists of a sequence of <code>CommandReceipt</code>, which provides a succinct summary of what happened during the execution of the corresponding <code>Command</code> in a transaction.</p> <p>A Command Receipt has the following fields:</p> <ul> <li><code>Exit Status</code>: tells whether the corresponding command in the sequence succeeded in doing its operation and, if it failed, whether the failure is because of gas exhaustion or some other reason.</li> <li><code>Gas Used</code>: how much gas was used in the execution of the transaction. This will at most be the transaction\u2019s gas limit.</li> <li><code>Return Values</code>: the return values of the corresponding command.</li> <li><code>Logs</code>: the logs emitted during the corresponding call command.</li> </ul> <p>Possible values for <code>Exit Status</code> are:</p> Code Name Description 0x00 Operation successful The command successfully did what it is supposed to do. 0x01 Operation failed The command failed to do what it is supposed to do. 0x02 Gas exhausted Execution halted in the middle of the command because the gas limit was hit. <p>Logs are topic-value pairs emitted during smart contract execution. Logs allow decentralized applications to quickly prove to users that a particular branch/line of code was executed during a transaction, by querying for the existence of logs in blocks.</p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"concepts/wallet/","title":"Wallet","text":"<p>A crypto wallet is a software program that stores private and public keys. It enable users to interact with blockchain networks by sending and receiving digital currency, as well as monitoring their balance. Crypto wallets can be used to manage different types of digital assets, including cryptocurrencies and non-fungible tokens (NFTs). There are different types of crypto wallets, like software wallets, hardware wallets, and paper wallets, each with its own set of features and benefits.</p> <p>A crypto wallet is important for keeping your keypairs safe. A keypair consists of two related cryptographic keys, a public key, and a private key. </p> <p>A public key is a cryptographic key that can be freely shared with anyone. This is used as an address to identify your account and receive funds, while a private key is used to sign transactions and should be kept confidential by the owner. When a user sends cryptocurrency to another user, they use the recipient's public key to encrypt the transaction, which can only be decrypted by the recipient with their private key.</p> <p>It is important to keep the private key secure, as anyone who has access to it can sign transactions and transfer funds out of the wallet. </p>","tags":["Wallet","XPLL"]},{"location":"concepts/staking/block_reward/","title":"Staking","text":"","tags":["Staking"]},{"location":"concepts/staking/block_reward/#block-reward","title":"Block reward","text":"<p>Block rewards in blockchain are a form of incentive that is given to validators who participate in the process of adding new blocks to a blockchain network. The process of adding new blocks to a blockchain is known as validating in delegated proof-of-stake (DPoS) blockchains.</p> <p>In DPoS blockchains, validators are chosen to validate transactions and create new blocks based on the amount of XPLL they have staked in the network. Validators are rewarded with a portion of the transaction fees and a portion of the block rewards for creating new blocks.</p> <p>Block rewards serve several purposes in blockchain networks. They incentivize miners and validators to participate in the network's consensus process, which helps to maintain the security and integrity of the network. Block rewards also provide a way to introduce new XPLL into circulation, which helps to ensure that the network is sustainable in the long term.</p> <p>Over time, the block reward amount decreases as more blocks are added to the blockchain. This is known as the block reward halving, and it is a feature of many blockchain networks, including Bitcoin. The block reward halving helps to control the supply of cryptocurrency and prevent inflation.</p>","tags":["Staking"]},{"location":"concepts/staking/delegator/","title":"Delegator","text":"<p>In a delegated proof-of-stake (DPoS) blockchain network, a delegator is a participant who delegates their tokens holdings to a staking pool to participate in the network's consensus process. Delegators do not validate transactions or create new blocks themselves, but they can participate in the network's consensus process by proxy through a pool.</p> <p>Delegating tokens to a pool allows the delegator to participate in the network's consensus process and earn rewards for doing so, without having to run a pool node themselves. Delegators typically choose a pool based on their reputation, track record, and the rewards they offer.</p> <p>Delegators are responsible for selecting a pool to delegate their tokens to and must be careful to choose a reputable and trustworthy one. Delegators can also switch pools at any time, which allows them to take advantage of new opportunities or switch to a different pool if their current pool is underperforming.</p> <p>Delegators typically earn rewards for participating in the network's consensus process, which is shared between the delegators and the pool operator they delegate to. The exact amount of rewards earned may depend on various factors, such as the number of tokens staked, the length of time the tokens are staked for, and the network's overall performance.</p> <p>Overall, delegation allows more participants to participate in the network's consensus process, which can help to increase the network's security and decentralization.</p>","tags":["Delegator","Staking","Pool"]},{"location":"concepts/staking/faq/","title":"Staking","text":"","tags":["Staking"]},{"location":"concepts/staking/faq/#faq","title":"FAQ","text":"","tags":["Staking"]},{"location":"concepts/staking/faq/#why-am-i-not-able-to-stake-xpll-tokens","title":"Why am I not able to stake XPLL tokens?","text":"<p>You will need to retain a certain amount of XPLL in your account balance to pay for transaction fees. Ensure that you have reserved a small amount of XPLL tokens to pay for the gas fee of your deposit, stake, or unstake XPLL tokens.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#how-do-i-know-which-validator-to-stake-with","title":"How do I know which validator to stake with?","text":"<p>The validators securing the ParallelChain Mainnet are trusted participants who are required to stake a significant number of XPLL. You may check the yield and commission fee of each validator by tapping on the drop-down arrow of the \u2018Operator\u2019 field.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#how-long-is-the-unstaking-period","title":"How long is the unstaking period?","text":"<p>The staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If the staking and unstaking are not within the same epoch, you will need to wait for at least another two epochs before unstaking.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#how-long-is-an-epoch","title":"How long is an Epoch?","text":"<p>One full epoch lasts approximately one day before it enters the next epoch. The epoch itself is a protocol-defined period for measuring the performance of operators on the network.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#how-do-i-withdraw-my-staking-rewards","title":"How do I withdraw my staking rewards?","text":"<p>You can withdraw the rewards you have earned from staking by unstaking them to your Token Deposit. Additionally, you may toggle the \u2018AUTO STAKE REWARDS\u2019 to avoid the process of unstaking your rewards. From there, you can then withdraw the amount to your wallet. Please refer to the section on Unstaking Your XPLL and Withdrawing Your Staking Rewards for the required steps.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#can-i-move-my-staked-xpll-to-another-validator","title":"Can I move my staked XPLL to another validator?","text":"<p>Yes, you can. You will need to unstake your XPLL tokens, withdraw them to the Token Deposit, and then back to your wallet. You can then transfer those tokens to a Token Deposit with another validator before staking your tokens with them. Please refer to the sections above to move your XPLL to another validator.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#can-i-stake-to-more-than-one-node","title":"Can I stake to more than one node?","text":"<p>Yes, you can. To do so, you will need to create a Token Deposit on the validator node you wish to stake with. Once done, you can stake tokens with the validator node. To stake XPLL with more than one validator, repeat the same process of creating a Token Deposit with the other validator node, deposit tokens from your account to the Token Deposit, and you can stake with the second validator. Repeat this process with other validator nodes you wish to stake with.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#the-status-is-still-showing-pending-why-is-my-transaction-not-confirmed-yet","title":"The status is still showing \u2018PENDING\u2019. Why is my transaction not confirmed yet?","text":"<p>Transactions are prioritized by the amount of Priority Fee per Gas paid, and lower priority transactions may need more time to be confirmed. You may choose to pay a higher Priority Fee during peak periods for a faster transaction, or you may check your wallet address on the blockchain explorer to monitor its transaction status.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#are-the-rewards-automatically-staked","title":"Are the rewards automatically staked?","text":"<p>Depends on the setting of your stake. Your staking rewards will not be automatically staked unless the AUTO STAKE REWARDS field is toggled on. You can toggle it on or off anytime you want.</p>","tags":["Staking"]},{"location":"concepts/staking/faq/#is-there-any-locking-period","title":"Is there any locking period?","text":"<p>There is no locking period to stake your XPLL tokens, but the staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If the staking and unstaking are not within the same epoch, you will need to wait for at least another two epochs before unstaking.</p>","tags":["Staking"]},{"location":"concepts/staking/how_does_staking_work/","title":"Staking","text":"","tags":["Staking"]},{"location":"concepts/staking/how_does_staking_work/#how-does-staking-work","title":"How does Staking Work?","text":"<p>In this staking process, there are two main actors: pool operators and owner. A pool operator can create, update, and destroy pools. An owner can deposit their cryptocurrency into a pool, top-up their deposit, withdraw their deposit, and set the amount they want to stake in the pool. However, they cannot stake more than the amount they have deposited.</p> <p>If a pool has enough power (determined by the amount of cryptocurrency staked), it can join as a validator in the next epoch. In each epoch, rewards are distributed to owners' deposits, and the validator set is updated according to the validators' power, which will determine the validators in consensus for the current epoch.</p> <p>An owner can withdraw their deposit from a pool, but the amount they withdraw cannot make their deposit less than the maximum stake amount in the current and previous epoch.</p> <p>Overall, the process allows operators to create and manage pools, owners to deposit and withdraw their funds while setting a stake amount, and rewards to be distributed to owners' deposits. The process also ensures the validator set is updated each epoch, which is important for the security and consensus of the network. Additionally, the restriction on withdrawals ensures that the pool always has enough stake to participate in the consensus process and maintains the security of the network.</p>","tags":["Staking"]},{"location":"concepts/staking/validator/","title":"Validator","text":"<p>In a delegated proof-of-stake (DPoS) blockchain network, a <code>validator</code> is a participant in the network who is responsible for validating transactions and creating new blocks. Validators are selected based on the amount of tokens they hold and their stake in the network. This stake serves as collateral and incentivizes validators to act honestly and maintain the security of the network.</p> <p>Validators in a DPoS network are responsible for two key functions: proposing new blocks and validating transactions. Validators propose new blocks by creating a block with a set of new transactions and adding it to the blockchain. To validate transactions, validators must check that the transaction is valid, that the sender has enough tokens to complete the transaction, and that the transaction is not a double spend.</p> <p>Validators in a DPoS network are chosen according to the amount they staked in the network. The more tokens a user stakes, the greater their chances of being selected to be one of the validators in the next epoch.</p>","tags":["Validator","Staking","Pool"]},{"location":"concepts/staking/what_is_staking/","title":"Staking","text":"","tags":["Staking"]},{"location":"concepts/staking/what_is_staking/#what-is-staking","title":"What is Staking?","text":"<p>Staking is a process of holding a cryptocurrency or token as a way to support the operations of a blockchain network. It involves locking up a certain amount of tokens for a period of time to participate in the process of validating transactions, adding new blocks to the chain, and maintaining the security and integrity of the network.</p> <p>In return for staking, users may receive rewards in the form of additional tokens issued by the network. In Parallelchain Mainnet, Staking is used in delegated proof-of-stake (DPoS) consensus algorithms, where validators are chosen based on the number of tokens they have staked, rather than the computational power they can provide, as in proof-of-work (PoW) algorithms.</p> <p>Elements inside a staking process include:</p> <ul> <li>Pool: a group of validators and delegators who combine their staking resources to increase their chances of being chosen to validate blocks and earn rewards.</li> <li>Stake: the cryptocurrency tokens that a participant locks up as collateral to become a validator or delegator.</li> <li>Deposit: the locked balance used to determine the amount of stake that can be contributed to a pool.</li> </ul>","tags":["Staking"]},{"location":"getting_started/contract_publish/","title":"Contract Publishing Service","text":"","tags":["pchain-compile","Contract Publishing Service"]},{"location":"getting_started/contract_publish/#what-is-contract-publishing-service","title":"What is contract publishing service?","text":"<p>The Contract Publishing Service is a platform that allows smart contract developers to verify their deployed source code on ParallelChain Mainnet.</p>","tags":["pchain-compile","Contract Publishing Service"]},{"location":"getting_started/contract_publish/#how-does-it-work","title":"How does it work?","text":"<p>The Contract Publishing Service follows these three steps:</p> <ol> <li>The service generates identity verification bytes using the contract address and transaction hash provided by the user.</li> <li>The user signs the ID bytes with the help of the ParallelChain client using the instructions provided on the front end, which generates a signature.</li> <li>The backend accepts the signature, GitHub link, and commit SHA of the source code. It builds the source code using <code>pchain_compile</code> and verifies the generated binary against the existing code on ParallelChain Mainnet. If the contract is successfully verified, the service returns a success status code to the user.</li> </ol>","tags":["pchain-compile","Contract Publishing Service"]},{"location":"getting_started/contract_publish/#about-the-word-verify","title":"About the word \"Verify\"","text":"<p>The contract publishing service in ParallelChain Mainnet relies on the user to provide a correct Github link and commit SHA of the source code. If the user provides incorrect information, the verification process may fail or result in a false positive. Additionally, the service only verifies the binary code generated from the source code, and does not verify the actual logic and functionality of the smart contract. Therefore, it is still important for smart contract developers to thoroughly test and audit their code before deployment to ensure its correctness and security.</p>","tags":["pchain-compile","Contract Publishing Service"]},{"location":"getting_started/create_account/","title":"Create Account","text":"<p>The guide will walk you through the steps to generate and manage your Mainnet / Testnet account by using <code>pchain_client</code>. Alternatively, you can generate account by using ParallelChain Explorer. Please refer to the Explorer Account Tutorial.</p>","tags":["pchain-client","account","mainnet","testnet 4","faucet"]},{"location":"getting_started/create_account/#generating-keypair","title":"Generating Keypair","text":"<p>To create an account, type the following command below:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys create --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys create --name &lt;NAME&gt;\n</code></pre> <p>You will be asked to input your password to save the new keypair.</p> <p>This command generates a set of ed25519_dalek-compatible keys. A keypair file in json format is created in the folder specified by the environment variable <code>PCHAIN_CLI_HOME</code>. These are the keys required for making transactions in the network. Its public key is the public address of your account. You can view it as follows:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys list\n</code></pre> <pre><code>./pchain_client.exe keys list\n</code></pre> Terminal Output <pre><code>Keypair Name (First 50 char)                        Public key \n-------------------------                           ------------------------- \ndoc                                                 mF0a_r31a_cNNnKbngoUGUuy71V_l872yGxy7iwIBwA\n</code></pre> <p>You will need the keypair and public key to submit transactions.</p> <p>You can check the account balance using the account address (public key).</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query balance --address &lt;ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query balance --address &lt;ADDRESS&gt;\n</code></pre> Terminal Output <pre><code>0\n</code></pre> <p>The balance of a new account is 0. Therefore, you need to request tokens from the faucet.</p>","tags":["pchain-client","account","mainnet","testnet 4","faucet"]},{"location":"getting_started/create_account/#exporting-keypair","title":"Exporting Keypair","text":"<p>Right now, the key pair is only in your machine. It will go away if your machine somehow breaks. It may also be lost if you forget your password. </p> <p>To secure your keypair and money, you must export it and save it somewhere secure, or at least make a copy of it.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys export --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys export --name &lt;NAME&gt;\n</code></pre> <p>You will be asked to input your password to export the keypair. The keypair will be saved in the current directory, in JSON format, with the same name as the keypair itself.</p>","tags":["pchain-client","account","mainnet","testnet 4","faucet"]},{"location":"getting_started/create_account/#importing-keypair","title":"Importing Keypair","text":"<p>To add your keypair, type the following command below:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys import --public &lt;PUBLIC_KEY/ADDRESS&gt; --private &lt;PRIVATE_KEY&gt; --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys import --public &lt;PUBLIC_KEY/ADDRESS&gt; --private &lt;PRIVATE_KEY&gt; --name &lt;NAME&gt;\n</code></pre> <p>You will be asked to input your password to import the new keypair.</p>","tags":["pchain-client","account","mainnet","testnet 4","faucet"]},{"location":"getting_started/create_account/#request-for-tokens-from-faucet-testnet","title":"Request for tokens from Faucet (Testnet)","text":"<p>The Faucet Service of our Testnet issues free testing tokens to users to test the blockchain network on Testnet. </p> <p>Right now, you have your keypair (account) to associate with the blockchain. But the account should have an empty balance. You can now request tokens from Faucet Service.</p>","tags":["pchain-client","account","mainnet","testnet 4","faucet"]},{"location":"getting_started/installation/","title":"Installation","text":"<p>ParallelChain client (<code>pchain_client</code>) is a command-line tool that allows you to connect and interact with the ParallelChain Mainnet / Testnet. <code>pchain_client</code> supports both Windows and Linux/macOS. In this tutorial, we will provide you with step-by-step instructions on how to install and use <code>pchain_client</code> to transfer tokens, deploy smart contracts, and call contracts.</p>","tags":["pchain-client"]},{"location":"getting_started/installation/#installation-instructions","title":"Installation Instructions","text":"","tags":["pchain-client"]},{"location":"getting_started/installation/#windows","title":"Windows","text":"<ol> <li>Download the latest release as a compressed file from Assets of ParallelChain Lab's GitHub release page.</li> <li>Unzip the file to extract the executable <code>pchain_client.exe</code>.</li> <li>Open Powershell by pressing WIN+R and typing <code>powershell</code>.</li> <li>Navigate to the directory where <code>pchain_client.exe</code> is located using the <code>cd</code> command. For example, if the executable is located at <code>C:\\Development</code>, type <code>cd C:\\Development</code>.</li> <li>Follow the instructions in Section Prepare Environment to get ready for interacting with the blockchain.</li> </ol>","tags":["pchain-client"]},{"location":"getting_started/installation/#linux-macos","title":"Linux / macOS","text":"<p>The installation process for Linux and macOS is similar. To install pchain_client:</p> <ol> <li> <p>Download the latest release as a compressed file from Assets of ParallelChain Lab's GitHub release page.</p> </li> <li> <p>Head to the directory where the downloaded file is located and extract it using <code>tar</code>. For example:</p> LinuxmacOS <pre><code>tar -xvf pchain_client_linux_v0.4.3.tar.gz \n</code></pre> <pre><code>tar -xvf pchain_client_mac_v0.4.3.tar.gz \n</code></pre> </li> <li> <p>Follow the instructions in Section Prepare Environment to get ready for interacting with the blockchain.</p> </li> </ol> <p>Tips</p> <ul> <li> <p>If you're using macOS and encounter a GateKeeper message when trying to run pchain_client, you can remove macOS' \"GateKeeper\" attributes from pchain_client using the following command: <pre><code>sudo xattr -rd com.apple.quarantine ./pchain_client\n</code></pre> This is an elevated action, so you will need to enter your password to continue. <code>pchain_client</code> can now be used as normal.</p> </li> <li> <p>You might want to store <code>pchain_client</code> in a directory of your choice so that it is easier to follow the commands in the tutorial. For example, we created a folder in our home directory called parallelchain_client: <pre><code>$ mkdir -p /home/my_user/parallelchain_client\n$ cp pchain_client /home/my_user/parallelchain_client/\n$ cd /home/my_user/parallelchain_client\n$ ./pchain_client\n</code></pre></p> </li> </ul>","tags":["pchain-client"]},{"location":"getting_started/prepare_env/","title":"Prepare Environment","text":"","tags":["pchain-client","mainnet","testnet","explorer"]},{"location":"getting_started/prepare_env/#setting-environmental-variables","title":"Setting Environmental Variables","text":"<p>Specify the location of the directory for storing your config and keypair by setting the environmental variable <code>PCHAIN_CLI_HOME</code>. </p> <p>Always remember the location that you set, if you forget the location, it means you forget where your keypair is being placed.</p> <p>Tips</p> <p>For security reasons, you may want to set environmental temporarily, so that after you close the terminal session, it will forget the keypair location.</p> <p>The following command will set the environmental variable temporarily:</p> Linux / macOSWindows PowerShell <pre><code># For example, \"/home/user/pchain_cli_home\"\nexport PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <pre><code># For example, \"C:\\Users\\user\\pchain_cli_home\"\n$Env:PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <p>For convenience reasons, you may alternatively want to set environmental permanently. Even in that case, we still suggest you remember the storage location.</p> <p>The following command will set the environmental variable permanently:</p> Linux / macOSWindows PowerShell (restart shell to pick up change) <pre><code>##########################################################\n## Append this line to $Home/.bashrc and $Home/.profile ##\n##########################################################\nexport PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <pre><code>setx PCHAIN_CLI_HOME \"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre>","tags":["pchain-client","mainnet","testnet","explorer"]},{"location":"getting_started/prepare_env/#creating-password","title":"Creating Password","text":"<p>For the first time to use <code>pchain_client</code>, you need to create your password for using it. The terminal should prompt you as follows:</p> <pre><code>First time using ParallelChain Client CLI. Please set up a password to protect your keypairs.\nYour password: \n</code></pre> <p>This password is only used by the CLI, and NOT associated with the blockchain. It is used for encryption and decryption of your keypairs so that the keypairs are stored in your computer more securely.</p>","tags":["pchain-client","mainnet","testnet","explorer"]},{"location":"getting_started/prepare_env/#setting-endpoint-interacting-with-parallelchain","title":"Setting Endpoint Interacting with Parallelchain","text":"<p>After installation of <code>pchain_client</code>, you had to update the Mainnet / Testnet endpoint to communicate with the Mainnet / Testnet. </p> Linux / macOSWindows PowerShell <pre><code># Mainnet\n./pchain_client config setup --url https://pchain-main-rpc02.parallelchain.io\n# Testnet\n./pchain_client config setup --url https://pchain-test-rpc02.parallelchain.io\n</code></pre> <pre><code># Mainnet\n./pchain_client.exe config setup --url https://pchain-main-rpc02.parallelchain.io\n# Testnet\n./pchain_client.exe config setup --url https://pchain-test-rpc02.parallelchain.io\n</code></pre> <p>This command will write a <code>config.toml</code> file in the folder specified by the environment variable <code>PCHAIN_CLI_HOME</code>. It only needs to be executed once.</p> <p>Now you can start the journey to play around with <code>pchain_client</code>, but there is still one thing you had to put in mind first.</p>","tags":["pchain-client","mainnet","testnet","explorer"]},{"location":"getting_started/staking/","title":"Staking","text":"<p>The staking process consists of several Staking Commands. Each command usually works with each other to serve a particular purpose. It is recommended to read paragraph How does staking work before trying out the commands which are described on this page.</p> <p>This page guides you to create staking transactions by using the CLI. The CLI creates a JSON file which can be used to submit the staking transaction in the same way as submitting transfer transaction.</p>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#creating-deposit","title":"Creating Deposit","text":"<p>First, before you stake, you have to lock up (stake) some balance tied to an operator to prepare for the stake. This step is done by the CLI subcommand <code>deposit create</code>, which reduces the balance of your account.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeposit create \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--balance &lt;BALANCE&gt; \\\n--auto-stake-rewards\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeposit create `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--balance &lt;BALANCE&gt; `\n--auto-stake-rewards\n</code></pre> <p>The last flag for <code>auto-stake-rewards</code> is optional. By default, it is false. It indicates whether your rewards should be staked to the Pool in each epoch.</p> <p>After you create a deposit, you can do follows:</p> <ul> <li>Top-up the amount of the deposit</li> <li>Update deposit settings (i.e. toggling <code>auto-stake-rewards</code>)</li> <li>Stake deposit to the pool</li> <li>Withdraw the deposit</li> </ul> <p>Important</p> <p>Now you have just created the Deposit to a Pool, but you still have no stake in the pool. At this stage, you will NOT have the rewards, because your reward amount is calculated by the amount that you staked, not the Deposit you created.</p>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#topping-up-deposit","title":"Topping up Deposit","text":"<p>After creating a Deposit in a Pool, use the CLI subcommands <code>deposit top-up</code> if you want to put more in the same Pool. </p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeposit top-up \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--amount &lt;AMOUNT&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeposit top-up `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--amount &lt;AMOUNT&gt;\n</code></pre>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#toggling-auto-stake-rewards","title":"Toggling <code>auto-stake-rewards</code>","text":"<p>You specified the flag <code>auto-stake-rewards</code> when you created the Deposit. You can change the value of this flag by submitting another transaction using the CLI subcommand <code>deposit update-settings</code>.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeposit update-settings \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--auto-stake-rewards\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeposit update-settings `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--auto-stake-rewards\n</code></pre>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#staking-and-unstaking","title":"Staking and Unstaking","text":"<p>After you create a Deposit to a Pool, you should now stake some amount of it to the pool with the CLI subcommand <code>stake stake</code>.  </p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\nstake stake \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\nstake stake `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <p>The <code>max-amount</code> specifies the maximum amount of Deposits that are going to stake. After submitting the transaction, the resulting staked amount is not necessary to be as same as the <code>max-amount</code>.</p> <p>You can also unstake your stake on with the CLI subcommand <code>stake unstake</code>.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\nstake unstake \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\nstake unstake `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#creating-transaction-with-multiple-staking-commands","title":"Creating Transaction with Multiple Staking Commands","text":"<p>Staking in a pool requires two steps: <code>Create Deposit</code> and <code>Stake Deposit</code>. But it does not mean that there must be two corresponding transactions to be made. You can create a single transaction with two staking commands. For example, you can do both <code>Create Deposit</code> and <code>Stake Deposit</code> in a transaction by the CLI command <code>append</code>.</p> <p>Suppose you created the transaction file (i.e. <code>tx.json</code>) from the step Creating Deposit.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction append \\\n--file &lt;PATH_TO_TRANSACTION_FILE&gt; \\\nstake stake \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction append `\n--file &lt;PATH_TO_TRANSACTION_FILE&gt; `\nstake stake `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <p>The transaction file will then be modified. Then, you can submit it as a single transaction.</p>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/staking/#withdrawing-deposit","title":"Withdrawing Deposit","text":"<p>Your Deposit can be increased due to reward distribution in each epoch. If you want to pull out the Deposit from the Pool to the balance of your account, make use of the CLI subcommand <code>deposit withdraw</code>.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeposit withdraw \\\n--operator &lt;OPERATOR_ADDRESS&gt; \\\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeposit withdraw `\n--operator &lt;OPERATOR_ADDRESS&gt; `\n--max-amount &lt;MAX_AMOUNT&gt;\n</code></pre> <p>The balance in your account will be increased for the Deposit that you withdrew from the Pool.</p> <p>Tips</p> <p>If you withdraw the Deposit without unstaking (assuming you already staked), you may not be able to withdraw all deposited tokens because you cannot withdraw the staked Deposit in the current Pool. In this case, you have to unstake first and wait for the next two epochs before you withdraw the Deposit.</p>","tags":["pchain-client","Staking","Network Transaction"]},{"location":"getting_started/transfer/","title":"Transfer Tokens","text":"<p>This guide will walk you through the process of transferring tokens on ParallelChain Mainnet / Testnet.</p>","tags":["pchain-client","mainnet","testnet"]},{"location":"getting_started/transfer/#creating-transaction-with-a-transfer-command","title":"Creating Transaction with a Transfer Command","text":"<p>To create a transaction, you first need to know the <code>nonce</code> of your account, which is an account-related entity required to submit a transaction. Here's how to check your account's <code>nonce</code> using <code>pchain_client</code>:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query nonce --address &lt;YOUR_ACCOUNT_ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query nonce --address &lt;YOUR_ACCOUNT_ADDRESS&gt;\n</code></pre> <p>When you run this command, you'll see the output of your account's <code>nonce</code> value, like this: <pre><code>0\n</code></pre></p> <p>Next, to transfer tokens from your account to someone else's account using <code>pchain_client</code>, you need to create a transaction file containing one transfer command first. </p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ntransfer \\\n--recipient &lt;RECIPIENT_ADDRESS&gt; \\\n--amount &lt;AMOUNT_TO_TRANSFER&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ntransfer `\n--recipient &lt;RECIPIENT_ADDRESS&gt; `\n--amount &lt;AMOUNT_TO_TRANSFER&gt;\n</code></pre> <p>A file with the name <code>tx.json</code> will be saved in the current directory if the <code>destination</code> flag is not specified. If you want to store the transaction file in your preferred location, specify the path with your preferred file name and JSON extension under the <code>destination</code> flag.</p> <p>Please note that <code>max-base-fee-per-gas</code> had to be at least 8.</p> <p>Make sure to replace </p> <ul> <li><code>&lt;NONCE&gt;</code> with your account's nonce value;</li> <li><code>&lt;GAS_LIMIT&gt;</code> with the gas limit of the transaction;</li> <li><code>&lt;MAX_BASE_FEE_PER_GAS&gt;</code> with the maximum base fee you want to pay;</li> <li><code>&lt;PRIORITY_FEE_PER_GAS&gt;</code> with the priority fee you want to pay;</li> <li><code>&lt;RECIPIENT_ADDRESS&gt;</code> with the recipient's account address;</li> <li><code>&lt;AMOUNT_TO_TRANSFER&gt;</code> with the number of tokens you want to transfer;</li> </ul>","tags":["pchain-client","mainnet","testnet"]},{"location":"getting_started/transfer/#submitting-transaction","title":"Submitting Transaction","text":"Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction submit --file &lt;PATH_TO_TRANSACTION_FILE&gt; --keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <pre><code>./pchain_client transaction submit `\n--file &lt;PATH_TO_TRANSACTION_FILE&gt; `\n--keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <p>After submitting the transaction to RPC successfully, you should receive a message that describes the content of the transaction. The transaction hash in the content will be useful later on when you want to check its status. Still, transactions may fail for various reasons. We suggest you test the transaction and estimate the gas used in the testnet.</p>","tags":["pchain-client","mainnet","testnet"]},{"location":"getting_started/transfer/#querying-transaction","title":"Querying Transaction","text":"<p>You can check the transaction status using <code>pchain_client</code> with the following command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query tx --hash &lt;TRANSACTION_HASH&gt; \n</code></pre> <pre><code>./pchain_client.exe query tx --hash &lt;TRANSACTION_HASH&gt;\n</code></pre> <p>Make sure to replace <code>&lt;TRANSACTION_HASH&gt;</code> with the transaction hash that you want to check.</p>","tags":["pchain-client","mainnet","testnet"]},{"location":"getting_started/transfer/#creating-transaction-with-multiple-transfer-commands","title":"Creating Transaction with Multiple Transfer Commands","text":"<p>You may append an extra transfer transaction with <code>pchain_client</code>. After creating a transaction with single transfer command in the last tutorial, instead of submitting the transaction, you can append extra command on the <code>tx.json</code> generated by <code>pchain_client</code>.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction append \\\n--file &lt;PATH_TO_TRANSACTION_FILE&gt; \\\ntransfer \\\n--recipient &lt;RECIPIENT_ADDRESS&gt; \\\n--amount &lt;AMOUNT_TO_TRANSFER&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction append `\n--file &lt;PATH_TO_TRANSACTION_FILE&gt; `\ntransfer `\n--recipient &lt;RECIPIENT_ADDRESS&gt; `\n--amount &lt;AMOUNT_TO_TRANSFER&gt;\n</code></pre> <p>Currently, if you construct a transaction with <code>pchain_client</code>, the fields <code>nonce</code>, <code>gas limit</code>, <code>max base fee per gas</code> and <code>priority fee per gas</code> are already filled in after calling command <code>create</code>. You need to manually change the transaction JSON file if you want to change them:</p> <p>After chaining up commands you are satisfied with, you can submit the transaction as you did in a single command transaction.</p>","tags":["pchain-client","mainnet","testnet"]},{"location":"introduction/what_parallelchain/","title":"What is ParallelChain","text":"<p>ParallelChain is a dual-blockchain ecosystem powered by two Layer-1 blockchain networks, ParallelChain Mainnet and ParallelChain Enterprise.</p> <p>ParallelChain Mainnet is a Delegated Proof-of-Stake open-source platform that is suitable for building decentralised, web2 and web3-interoperable blockchain applications; and ParallelChain Enterprise is a business-native, permissioned blockchain that supports decentralised enterprise solutions that feature stronger privacy, scalability, and compliance features. The coupling of both blockchains in a permissioned-permissionless blockchain interoperability will bring Web2 and Web3 into a scalable, networked economy.</p> <p>The continued development of ParallelChain is supported by the ParallelChain Foundation, an independent governance body based in Switzerland, and it is dedicated to increasing awareness and growing a strong builder community for ParallelChain.</p>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/why_parallelchain/","title":"Why ParallelChain?","text":"<p>ParallelChain excels where most other blockchains stumble, and that is driving near instant transactions on its dual-blockchain ecosystem, its scalability, and network security.</p> <p>Both blockchains that make up ParallelChain operate at a high transaction speed, with the public ParallelChain Mainnet operating at an average of 80,000 transactions per second, while the permissioned ParallelChain Enterprise operates at 130,000 transactions per second with a 3 millisecond finality.</p> <p>This contributes to the ease of scalability for public decentralised applications and enterprise solutions alike, as both networks can help projects and companies scale up the amount of bandwidth needed especially during peak usage where on-chain activities such as NFT minting periods could easily clog up the network and raise transaction gas fees.</p> <p>Moreover, heterogenous blockchains are unable to inter-communicate meaningfully due to their difference in architecture and consensus mechanism. With ParallelChain, the blockchain network achieves true native chain communication between permissioned and permissionless chains for deep level interoperability and allow enterprise users to tap into the decentralised space in a private, secure manner with Inter-ParallelChain Communication (IPC).</p> <p>IPC essentially acts as the bridge that connects the enterprise chain to DeFi networks built on the ParallelChain Mainnet, and this enables decentralised applications (dApps) to work across both layers. By doing so, we create wider accessibility between communities that are traditionally isolated.</p>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/xpll/how_to_get/","title":"How to Get XPLL","text":"<p>There are several ways to obtain XPLLs, the native tokens of ParallelChain.</p>","tags":["XPLL"]},{"location":"introduction/xpll/how_to_get/#staking-rewards","title":"Staking Rewards","text":"<p>Users can stake XPLL with the network validators to help secure the blockchain and earn rewards in the meantime. Staking is a process of locking up a certain amount of XPLL for a period of time in the process of validating transactions, adding new blocks, etc. Therefore, users will be rewarded with additional XPLL for contributing to the security and integrity of the network.</p> <p>To learn more about staking, read Staking.</p>","tags":["XPLL"]},{"location":"introduction/xpll/how_to_get/#ecosystem-activities-ambassador-programme","title":"Ecosystem Activities - Ambassador Programme","text":"<p>Users can earn XPLL by participating in our Ambassador Programme on Zealy.io. There are a variety of tasks and missions for community members to complete. In return, community members will receive rewards, perks, and badges by leveling up on Zealy. This is an opportunity for community members to earn XPLLs while keeping everyone engaged.</p> <p>For more information about the ParallelChain Ambassador Programme, read here.</p>","tags":["XPLL"]},{"location":"introduction/xpll/how_to_get/#kucoin","title":"KuCoin","text":"<p>XPLL is now listed on KuCoin, and the XPLL/USDT trading pair is available on the KuCoin platform. You can simply create an account on KuCoin, deposit your fund, and start trading for XPLL. </p> <p>KuCoin is a global cryptocurrency exchange with a user-oriented platform that focuses on inclusiveness and community action reach. It offers over 700 digital assets and currently provides spot trading, margin trading, P2P fiat trading, futures trading, staking, and lending to its 27 million users in 207 countries and regions. KuCoin is currently one of the top 5 crypto exchanges, according to CoinMarketCap.</p> <p>For more information about the listing of XPLL, read here.</p>","tags":["XPLL"]},{"location":"introduction/xpll/what_is_xpll/","title":"What is XPLL","text":"<p>XPLL is the native cryptocurrency of ParallelChain Mainnet (TXPLL in Testnet). The users of the ParallelChain Mainnet need XPLLs to pay for their transaction fees when using the network. The transaction fee is denoted in GRAY, the smallest unit of XPLL, where 1 GRAY = 0.00000001 XPLL. Other than that, XPLL also plays an important role in this Delegated Proof-of-Stake (DPoS) Mainnet; it incentivizes good behaviors and punishes actions that threaten the network's security, availability, and user experience.</p> <p>For more information about XPLL, including allocations, circulation, and inflation, please refer to the XPLL Token Metrics.</p>","tags":["XPLL","TXPLL","Gray"]},{"location":"introduction/xpll/what_is_xpll/#utilities","title":"Utilities","text":"<p>XPLL acts like your ticket to the ParallelChain Ecosystem; its utilities include the following:</p> <ul> <li>Pay transaction fees on ParallelChain</li> <li>Stake XPLL to run a validator node</li> <li>Delegate to earn block rewards</li> <li>Vote on proposals and help govern the network</li> </ul>","tags":["XPLL","TXPLL","Gray"]},{"location":"introduction/xpll/what_is_xpll/#denomination","title":"Denomination","text":"<p>The smallest denomination of XPLL is called Gray. Users buy XPLL to pay for gas costs with the ParallelChain Mainnet and other purposes as mentioned in the Utilities section. </p> <p>The goal of defining a denomination for XPLL is to standardize its scale with all currencies in the financial system. The table below shows the different denominations of XPLL, their abbreviations, and their equivalent values in terms of XPLL.</p> Denomination Abbreviation Value in XPLL Gray Gr 0.00000001 XPLL KiloGray KGr 0.00001 XPLL MegaGray MGr 0.01 XPLL XPLL XPLL 1 XPLL TeraGray TGr 10000 XPLL PetaGray PGr 10000000 XPLL <p>Gray is named in honor of James Nicholas Gray, a renowned computer scientist who was considered a pioneer in modern database technology. He was the award winner of the prestigious ACM Turing Award in 1998, which is the highest distinction in the field of computer science.</p>","tags":["XPLL","TXPLL","Gray"]},{"location":"running_nodes/requirement/","title":"Requirements","text":"","tags":["Requirements"]},{"location":"running_nodes/requirement/#hardware-requirements","title":"Hardware Requirements","text":"<p>Available soon.</p>","tags":["Requirements"]},{"location":"running_nodes/requirement/#software-requirements","title":"Software Requirements","text":"","tags":["Requirements"]},{"location":"running_nodes/requirement/#operating-system","title":"Operating System","text":"<p><code>Ubuntu 20.04</code></p>","tags":["Requirements"]},{"location":"running_nodes/requirement/#toolchain","title":"Toolchain","text":"Toolchain Component Version Utility rustc 1.66.1 (ad779e08b 2023-01-10) Compiler for Rust","tags":["Requirements"]},{"location":"running_nodes/requirement/#required-packages","title":"Required packages","text":"Package Name Version libssl-dev 1.1.1f-1ubuntu2.16 zlib1g-dev 1:1.2.11.dfsg-2ubuntu1.4 build-essential 12.8ubuntu1 clang 10.0.0-4ubuntu1","tags":["Requirements"]},{"location":"running_nodes/running_node/","title":"Running a Node","text":"","tags":["Running Nodes"]},{"location":"running_nodes/running_node/#set-up","title":"Set up","text":"<p>Generate <code>config.toml</code> along with <code>keypair.json</code>, <code>genesis.json</code> and <code>config.toml</code></p> <p>\u2757To join a network, make sure <code>genesis.json</code> is exactly the same as other members participating in the network.</p> <p>Example Config File <pre><code>   title = \"Fullnode Configuration\"\n\n   standard_api_listening_port = 40000\n   logs_path = \"/tmp/parallelchain-f/logs\"\n\n   [engine]\n   app_id = 0\n   produce_block_time_limit = 5000\n   validate_block_time_limit = 5000\n   blocks_per_epoch = 8\n\n   [engine.executor]\n   contract_cache_folder = \"/home/.parallelchain/fullnode/contract_cache\"\n   contract_memory_limit = 1073741824\n\n   [engine.genesis]\n   genesis_path = \"/home/.parallelchain/fullnode/config/genesis.json\"\n   genesis_timestamp = 1672531200\n   treasury_address = \"HLW3Lch72b2m9snDwDF8pHgm_0mwzyTgnM_VtRRQfg4\"\n\n   [node]\n   identity_path = \"/home/.parallelchain/fullnode/config/keypair.json\"\n   block_tree_storage_path = \"/home/.config/parallelchain/hotstuff_rs/block_tree_storage\"\n\n   [pacemaker]\n   minimum_view_timeout = 10\n   sync_request_limit = 10\n   sync_response_timeout = 3\n\n   [network]\n   listening_port = 30000\n   send_command_buffer_size = 8\n   private_msg_buffer_size = 1024\n   broadcast_msg_buffer_size = 1024\n   peer_discovery_interval = 10\n\n   # hotstuff_rs.static_participant_set represents the list of participants that belong to \n   # `hotstuff_rs::config::Configuration::static_participant_set`. In this example, only one participant\n   # is available. Duplicate this entire segment [[hotstuff_rs.static_participant_set]] if you intend \n   # to add more participants.\n   [[network.bootstrap]]\n   address = \"k9LhEzdX7SxssikrwNFMGiRfj4ugM3u3LNJvE0MY63U\"\n   ip_address = \"172.16.3.1\"\n   port = 30000\n   [[network.bootstrap]]\n   address = \"wT7l6TSj3h6Gg6xJQof-woz0qtYBrb-kLxWxO5q5sTw\"\n   ip_address = \"172.16.3.2\"\n   port = 30000\n   [[network.bootstrap]]\n   address = \"l1RjOEHtM-RvUh7BxmCBgu33Pw1vqb8AgKJLMLqz3js\"\n   ip_address = \"172.16.3.3\"\n   port = 30000\n   [[network.bootstrap]]\n   address = \"ipy_VXNiwHNP9mx6-nKxht_ZJNfYoMAcCnLykpq4x_k\"\n   ip_address = \"172.16.3.4\"\n   port = 30000\n</code></pre></p> <p>Tips</p> <ul> <li>Make sure keypair and ip pairs underneath network are consistent with the previous bootstrapped nodes present in the network. </li> <li>Add your own public key and ip_address in this section.</li> <li>Make sure your keypair file is kept in the correct identity_path provided in <code>config.toml</code>.</li> </ul>","tags":["Running Nodes"]},{"location":"running_nodes/running_node/#run-binary","title":"Run Binary","text":"<p>Run fullnode binary:</p> <p>=== start from genesis <pre><code>./fullnode --config-path /home/.parallelchain/fullnode/config/config.toml start-from-genesis\n</code></pre></p> <p>=== have existing storage <pre><code>./fullnode --config-path /home/.parallelchain/fullnode/config/config.toml \n</code></pre></p>","tags":["Running Nodes"]},{"location":"smart_contract_sdk/build_contract/","title":"Building the Contract with pchain_compile","text":"<p>pchain_compile is a CLI build tool for smart contract developers to build their source code to WASM binaries for deployment on  ParallelChain Mainnet. </p> <p>The WASM binary generated from a generic cargo build process has the following disadvantages: </p> <ul> <li> <p>The build process is not toolchain version agnostic i.e. it does not guarantee uniform WASM binaries with different versions of compiler and      rust crate dependencies. This will make it difficult for smart contract developers to verify their source code on the blockchain.</p> </li> <li> <p>The build process generates a large file size, which leads to higher gas costs for deployment and contract calls.</p> </li> </ul> <p>pchain_compile solves these shortcomings by: </p> <ul> <li> <p>Executing the build process in a docker environment with pre-defined toolchain versioning.</p> </li> <li> <p>Optimizing and compressing the size of the WASM binary with the help of <code>wasm-snip</code> and <code>wasm-opt</code> packages.</p> </li> </ul>","tags":["pchain-sdk","pchain-compile","Smart Contract"]},{"location":"smart_contract_sdk/build_contract/#downloading-pchain_compile","title":"Downloading pchain_compile","text":"<p><code>pchain_compile</code> supports Linux, macOS and Windows. Depending on the operating system, they can be downloaded from Assets of ParallelChain Lab's Git Hub release page.</p> <p>The binary can also be installed and built by executing the following commands: <pre><code>cargo install pchain_compile\n</code></pre></p> <p>Pre-requisites</p> <p><code>pchain_compile</code> builds the source code in a docker environment. To know more about Docker and install it, refer to the official instructions.</p>","tags":["pchain-sdk","pchain-compile","Smart Contract"]},{"location":"smart_contract_sdk/build_contract/#build-wasm-binary","title":"Build WASM Binary","text":"<p>In order to build a <code>WASM</code> binary of the smart contract, run the following command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_compile build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <pre><code>./pchain_compile.exe build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <p>If you installed <code>pchain_compile</code> with <code>cargo install</code>, you can simply run:</p> <pre><code>pchain_compile build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <p>A <code>.wasm</code> file will be generated in the current directory. It will be needed for the next section.</p>","tags":["pchain-sdk","pchain-compile","Smart Contract"]},{"location":"smart_contract_sdk/call_contract/","title":"Call Contract","text":"","tags":["pchain-client","Call","Smart Contract"]},{"location":"smart_contract_sdk/call_contract/#preparing-contract-method-arguments","title":"Preparing Contract Method Arguments","text":"<p>Suppose you have already deployed a contract that contains a <code>call</code> method as follows:</p> <pre><code>    #[call]\n    fn hello_from(name: String) -&gt; u32 {\n        pchain_sdk::log(\n            \"topic: Hello From\".as_bytes(), \n            format!(\"Hello, Contract. From: {}\", name).as_bytes()\n        );\n        name.len() as u32\n    }\n</code></pre> <p>To invoke this contract in the blockchain by using <code>pchain_client</code>, you can prepare a JSON file that contains a list of arguments and matches with the <code>call</code> method. For example, this <code>call</code> method takes a string argument. Then, the content of the JSON file should be as follows:</p> <pre><code>{\n    \"arguments\": [\n        {\"argument_type\":\"String\", \"argument_value\": \"\\\"Alice\\\"\"}\n    ]\n}\n</code></pre> <p>This JSON file will be used in the subcommand <code>call</code> as mentioned in the subsequent sections on this page.</p>","tags":["pchain-client","Call","Smart Contract"]},{"location":"smart_contract_sdk/call_contract/#calling-contract","title":"Calling Contract","text":"<p>To call a smart contract, submit a transaction with your account nonce and contract address using the <code>pchain_client</code>.</p> <p>Here is the command to call a contract:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ncall \\\n--target &lt;CONTRACT_ADDRESS&gt; \\\n--method &lt;contract_METHOD&gt; \\\n--arguments &lt;CALL_ARGUMENT_FILE_PATH_WITH_FILE_NAME&gt;\n--amount &lt;AMOUNT_TO_CONTRACT&gt; \\\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ncall `\n--target &lt;CONTRACT_ADDRESS&gt; `\n--method &lt;contract_METHOD&gt; `\n--arguments &lt;CALL_ARGUMENT_FILE_PATH_WITH_FILE_NAME&gt; `\n--amount &lt;AMOUNT_TO_CONTRACT&gt;\n</code></pre> <p>The gas limit required for the transaction depends on the complexity of the smart contract. For safety reasons, you can always set a higher gas limit. You can also test contract calls on testnet to reassure.</p> <p>Then you can submit the transaction in the same way as submitting transfer transaction.</p> <p>To query the resulting receipt of the transaction, </p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query tx --hash &lt;TRANSACTION_HASH&gt; \n</code></pre> <pre><code>./pchain_client.exe query tx --hash &lt;TRANSACTION_HASH&gt;\n</code></pre> <p>The commands stored in <code>transaction</code> and command receipts in <code>receipt</code> are following the same order. That means you can always find the corresponding transaction from a command receipt.</p>","tags":["pchain-client","Call","Smart Contract"]},{"location":"smart_contract_sdk/call_contract/#parse-call-result","title":"Parse Call Result","text":"<p>To parse the response from the contract method, represented in the field named <code>return value</code> , which is in <code>CallResult</code> format, you can use the <code>parse call-result</code> command in ParallelChain Client.</p> <p>For example, if the contract method returns a u32 integer, the <code>return value</code> is \"BAAAAAUAAAA\" you can parse the <code>CallResult</code> data structure using the <code>--data-type u32</code> flag:</p> Linux / macOSWindows PowerShell <pre><code>pchain_client parse call-result --value BAAAAAUAAAA --data-type u32\n</code></pre> <pre><code>./pchain_client.exe parse call-result --value BAAAAAUAAAA --data-type u32\n</code></pre> <p>The output will be the parsed value of the <code>CallResult</code>, which in this case is <code>4</code>. For more details, you can use the <code>help</code> command to see the usage of the tool or take a look at the example <code>argument,json</code>.</p>","tags":["pchain-client","Call","Smart Contract"]},{"location":"smart_contract_sdk/deploy_contract/","title":"Deploy Contract","text":"<p>This guide will walk you through the process of deploying your smart contract on ParallelChain Mainnet.</p>","tags":["Smart Contract","pchain-client"]},{"location":"smart_contract_sdk/deploy_contract/#deploying-a-smart-contract","title":"Deploying a Smart Contract","text":"<p>You can deploy the contract using the pchain_client command line tool. You should make sure to obtain your latest account nonce before submitting the transaction.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeploy \\\n--contract-code &lt;WASM_BINARY_PATH&gt; \\\n--cbi-version &lt;CBI_VERSION&gt; \n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeploy `\n--contract-code &lt;WASM_BINARY_PATH&gt; `\n--cbi-version &lt;CBI_VERSION&gt; \n</code></pre> <p>Then you can submit the transaction in the same way as submitting transfer transaction.</p>","tags":["Smart Contract","pchain-client"]},{"location":"smart_contract_sdk/deploy_contract/#checking-contract-in-state","title":"Checking Contract in State","text":"<p>To verify that the smart contract is deployed correctly, you can run the command <code>query</code> with the flag <code>contract</code>. It queries the state of the blockchain and saves the wasm code as <code>code.wasm</code> in the current directory. If you want to store the contract file in your preferred location, you need to provide the flag <code>destination</code> to specify the path with your preferred file extension:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query contract --address &lt;CONTRACT_ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query contract --address &lt;CONTRACT_ADDRESS&gt;\n</code></pre>","tags":["Smart Contract","pchain-client"]},{"location":"smart_contract_sdk/develop_contract/","title":"Develop Contract","text":"<p>Before we dive deep into the structure of a contract and the SDK's semantics, we require some background information about the semantics enforced by ParallelChain Mainnet. The full capabilities of ParallelChain Mainnet continue to grow with active developers  and a growing community. Let's see how smart contracts are called and processed by a node in the form of transactions.</p> <p>First, the ParallelChain Client (<code>pchain_client</code>) will submit a transaction when making a smart contract call to the validating node using a serialization crate pchain-types. The node's RPC service and mempool will process the list of transactions and check for validity and correctness. </p> <p>Transactions that fail the validation check may not be included in a block. The transactions are then packed in a block and sent to the execution engine in the node to execute the transactions. </p> <p>The executor will call <code>wasmer</code> (Web Assembly Engine) which provides an isolated context to perform the execution. This enables the smart contract code to read the current state of the blockchain and interact with it. However, the execution results are temporarily stored and subject to further checks before the block may be committed or rolled back on error. </p> <p><code>wasmer</code> also computes the gas fees through a metering module, which is responsible for limiting the execution to the amount of gas paid. Each transaction returns a result in the form of receipts along with logs. The receipts (with or without log), transactions and block itself will contain its hash (or Merkle proof) and will be all included in the same block.</p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/develop_contract/#smart-contract-development-kit","title":"Smart Contract Development Kit","text":"<p>Smart Contract can be created by using ParallelChain SDK. Example contracts can be found in example-smart-contracts.</p> <p>A ParallelChain Smart Contract is a rust crate that imports the SDK. It uses the SDK's features to interact with the blockchain. The folder structure of a typical ParallelChain Mainnet Smart Contract looks like this: <pre><code>my_first_contract\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 lib.rs # The main source code of your smart contract.  \n\u2514\u2500\u2500 Cargo.toml # You import your packages and the SDK here\n</code></pre></p> <p>For more information on Rust's crate system, see Rust Book Chapter 7: Packages and Crates</p> <p>Please specify the dependency in <code>Cargo.toml</code> for using SDK by fetching from crates.io or repository in Github.</p> Crates.ioGithub <pre><code>[dependencies]\npchain-sdk = \"0.4\"\n</code></pre> <pre><code>[dependencies]\npchain-sdk = { git = \"https://github.com/parallelchain-io/pchain-sdk\" }\n</code></pre>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/installation/","title":"Install SDK","text":"","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/installation/#install-rust","title":"Install Rust","text":"<p>To install the required toolkits, the standard method is by <code>rustup</code>, which maintains dependencies and is a version manager for <code>cargo</code> and <code>rustc</code> (the rust compiler). Detailed installation instructions can be found on the official website</p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/installation/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>A recommended Integrated Development Environment (IDE) is VSCode, which allows the addition of the rust plugin or rust-analyzer to type-check all of your code on save. This feature allows you to locate errors in the code easily, and the error messages displayed in the IDE are the same as when executing the <code>cargo build</code> command. However, any other editor that is comfortable for you can be used. However, any other editor that is comfortable for you can be used.</p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/installation/#install-wasm-toolchain-optional","title":"Install Wasm Toolchain (Optional)","text":"<p>ParallelChain Mainnet also provides a smart contract compilation tool called <code>pchain-compile</code> to compile your Rust smart contract into WASM bytecode. While not necessary, the Installation of Wasm Toolchain can help check if your code is compilable before using the time-consuming process in the use of <code>pchain-compile</code>.</p> <p>The <code>wasm32-unknown-unknown</code> toolchain is required for smart contracts to compile as WASM. To add the wasm toolchain in Rust, type the command below: <pre><code>rustup target add wasm32-unknown-unknown\n</code></pre></p> <p>To build your smart contract as WASM bytecode, use the command below: <pre><code>cargo build --target wasm32-unknown-unknown\n</code></pre></p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"smart_contract_sdk/introduction/","title":"SDK","text":"<p>The ParallelChain Mainnet Contract SDK (pchain-sdk) is an open-source Rust crate that helps to build smart contracts. It provides Rust structs, functions, types, and macros that aid with the development of smart contracts executable in WebAssembly (WASM) engines, implementing the ParallelChain Mainnet Contract Binary Interface (CBI) Subprotocol.</p> <p>Contracts are the run-time programmability mechanism of ParallelChain Mainnet networks. They allow users (Account owners) to implement arbitrary logic in a global, decentralized, and Byzantine Fault Tolerant replicated state machine to support their most business-critical applications.</p> <p>Theoretically, any WebAssembly (WASM) module that implements the CBI Subprotocol can be deployed onto a ParallelChain Mainnet blockchain. Practically, however, all developers (except perhaps those who like to experiment, or that would like to stretch the limits of the system) will want to use the types and macros provided in this pchain-sdk to write a Contract and the commands in pchain-compile to compile the Rust source code into WASM bytecode that can be included in a Deploy Transaction.</p> <p>This documentation is for both novice and advanced users alike. We hope to guide you to the success of your first smart contract creation in ParallelChain.</p> <p>For sharing the smart contract code, address, or any help with creating smart contracts, please go to GitHub Discussions.</p> <p>If you have any issues related to the SDK or smart contract, please go to GitHub issues.</p>","tags":["Tools","pchain-sdk","Smart Contract"]},{"location":"smart_contract_sdk/prepare_env/","title":"Prepare Environment","text":"<p>In this section, you need the tools and environment to develop and run smart contracts. You can utilize our Mainnet to deploy and make contract calls. You may consider testing your transaction on Testnet before doing it on Mainnet.</p>","tags":["mainnet","testnet","explorer"]},{"location":"smart_contract_sdk/prepare_env/#checking-the-network","title":"Checking the Network","text":"<p>You can check the mainnet network by viewing the Explorer website:</p> <ul> <li>ParallelChain Mainnet Explorer </li> </ul> <p>The explorer can explore transactions, addresses, information about the network, and blocks.</p> <p>To verify that testnet node is alive:</p> <ul> <li>https://pchain-test-rpc02.parallelchain.io</li> </ul> <p>You can use ParallelChain Client (called <code>pchain_client</code>) to interact with the <code>testnet</code> node.</p>","tags":["mainnet","testnet","explorer"]},{"location":"smart_contract_sdk/prepare_env/#setup-parallelchain-client","title":"Setup ParallelChain Client","text":"<p>Before we start developing the smart contracts, the <code>pchain_client</code> executable needs to be configured.</p> <p>If you are not yet familiar with <code>pchain_client</code>, See Getting Started to install <code>pchain_client</code> and learn about basic functionalities before proceeding with smart contract development.</p>","tags":["mainnet","testnet","explorer"]},{"location":"smart_contract_sdk/advance/contract_storage/","title":"Contract Storage","text":"<p>Contracts can use Storage to persist data between calls. The simplest way to read and write data into Storage is to add fields to the Contract struct:</p> <pre><code>#[contract]\nstruct PrinceTheDog {\n    age: u8, \n    breed: String,\n    hungry: bool,\n    toy: DogToy,\n}\n</code></pre> <p>The <code>#[contract]</code> macro transparently generates code that loads all of a Contract struct's fields from Storage before the execution of the contract method and saves those fields into Contract Storage after the contract method returns. All types that implement the <code>Storage</code> trait can be used as a Contract field. Out of the box, this includes all Rust primitive types, as well as other commonly used types like <code>Option&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. In addition, structs defined by the developer can be made to implement <code>Storage</code> by applying the <code>#[contract_field]</code> macro on their definitions, provided that all of their fields implement Storage:</p> <pre><code>#[contract_field]\nstruct DogToy {\n    ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#accessing-storage","title":"Accessing Storage","text":"<p>SDK provides functions to access Storage by read-write operations. The function <code>get_network_state</code> is particularly used to get the state from the Network Account of the blockchain.</p> <p>Related APIs in <code>pchain_sdk::storage</code>:</p> <pre><code>/// Gets the value, if any, associated with the provided key in this Contract Storage.\npub fn get(key: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;\n/// Gets the value, if any, associated with the provided key in Network Account's Storage.\npub fn get_network_state(key: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;\n/// Binds the provided key to the provided value in this Contract's Storage.\npub fn set(key: &amp;[u8], value: &amp;[u8]);\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#storage-and-collections","title":"Storage and Collections","text":"<p>Because Storage is so gas-expensive, loading all of a Contract's fields before Method execution and writing them all into Storage after execution typically results in Contracts that are not very economical. For Contracts that do not keep much in Storage, or whose Methods always read and write into most fields, this may be okay, or even ideal, however, some applications cannot avoid keeping a lot of on-chain states, and for these applications eagerly loading and saving fields in every call may be unacceptably expensive.</p> <p>To solve this, the SDK includes a <code>pchain_sdk::collections</code> module. All of the types defined in this module 'lazily' load Storage: they only incur a read or write gas cost when the exact item in the collection is read from or written to. They also offer an API that can make working with large collections of data more convenient.</p> <pre><code>#[contract]\nstruct PrinceTheDog {\n    nicknames: Vector&lt;String&gt;\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#cacher-cachert","title":"Cacher (<code>Cacher&lt;T&gt;</code>)","text":"<p>Wraps over any non-collections type that implements <code>Storage</code> and makes them lazy (all <code>collections</code> types are already lazy without Cacher). Cacher implements <code>Deref</code>, so <code>Cacher&lt;T&gt;</code> can be used almost everywhere <code>T</code> can be used without any special syntax. </p> <p>In the example below, the contract field <code>lazy_cat</code> is a <code>Cacher</code> of <code>String</code>. Passing the immutable receiver <code>&amp;self</code> to the method does not immediately load its data from the world state until dereferencing the field <code>lazy_cat</code>. In the method<code>set_cat_name</code>, the calling function <code>set</code> does not immediately save its data to the world state until the end of this method call.</p> <pre><code>#[contract]\nstruct Pet {\n    lazy_cat: Cacher&lt;String&gt;\n}\n\n#[contract_methods]\nimpl Pet { \n\n    //...\n\n    #[call]\n    fn cat_name(&amp;self) -&gt; String {\n        self.lazy_cat.to_uppercase()\n    }\n\n    #[call]\n    fn set_cat_name(&amp;mut self, name: String) {\n        self.lazy_cat.set(name);\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#vector-vectort","title":"Vector (<code>Vector&lt;T&gt;</code>)","text":"<p>Lazily stores a list of items in <code>Storage</code>. Vector implements <code>Index</code>, <code>IndexMut</code>, and has an <code>iter</code> method, so most of the things you can do with <code>std::vec::Vec</code>, you can probably do with <code>Vector</code> too.</p> <p>In the below example, the contract field <code>nicknames</code> is a <code>Vector</code> of <code>String</code>. It loads data from the world state only when it is needed to be read, and stores data after the method call. It calls <code>iter()</code> to get an iterator as <code>std::vec::Vec</code> and cal <code>push()</code> to save data to the world state. Besides, it supports indexing for accessing particular indexed elements.</p> <pre><code>#[contract]\nstruct Me {\n    nicknames: Vector&lt;String&gt;\n}\n\n#[contract_methods]\nimpl Me { \n\n    // ...\n\n    #[call]\n    fn my_name_is(&amp;self, name: String) -&gt; bool {\n        self.nicknames.iter().any(|n| n == &amp;name)\n    }\n\n    #[call]\n    fn call_me(&amp;mut self, name: String) {\n        self.nicknames.push(&amp;name);\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#maps-fastmapk-v-and-iterablemapk-v","title":"Maps (<code>FastMap&lt;K, V&gt;</code> and <code>IterableMap&lt;K, V&gt;</code>)","text":"<p>Collections include two types that store statically typed mapping between keys and values. The difference between these two types is that IterableMap is, as its name suggests, iterable. i.e., it has the standard library's HashMap's <code>keys</code>, <code>iter</code>, and <code>values</code> sets of methods. This functionality comes at the cost of storing slightly more data in Storage than FastMap. Both types function identically otherwise, down to being able to nest like-Maps together (e.g., <code>FastMap&lt;T, FastMap&lt;K, V&gt;&gt;</code>, but not <code>FastMap&lt;T, IterableMap&lt;K, V&gt;&gt;</code>).</p> <p>You should use IterableMap if your application needs to iterate through stored items, otherwise, use FastMap.</p>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#example-fastmapk-v","title":"Example - FastMap&lt;K, V&gt;","text":"<pre><code>type Address = [u8; 32];\n\n#[contract]\nstruct NameResolution {\n    name_mapping: FastMap&lt;Address, String&gt;\n}\n\n#[contract_methods]\nimpl NameResolution { \n\n    // ...\n\n    #[call]\n    fn resolve(&amp;self, address: Address) -&gt; Option&lt;String&gt; {\n        self.name_mapping.get(&amp;address)\n    }\n\n    #[call]\n    fn add_record(&amp;mut self, address: Address, name: String) {\n        self.name_mapping.insert(&amp;address, name)\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/contract_storage/#example-iterablemapk-v","title":"Example - IterableMap&lt;K, V&gt;","text":"<pre><code>#[contract]\nstruct Market {\n    prices: IterableMap&lt;String, u32&gt;\n}\n\n#[contract_methods]\nimpl Market {\n\n    // ...\n\n    #[call]\n    fn price(&amp;self, item: String) -&gt; Option&lt;u32&gt; {\n        self.prices.get(&amp;item)\n    }\n\n    #[call]\n    fn set_price(&amp;mut self, item: String, price: u32) {\n        self.prices.insert(&amp;item, price);\n    }\n\n    #[call]\n    fn total_price(&amp;self) -&gt; u32 {\n        self.prices.values().sum()\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"smart_contract_sdk/advance/cross_contract/","title":"Cross Contract Call","text":"<p>The SDK includes two functions to make Contract-to-Contract calls: <code>call</code> and <code>call_untyped</code>, the former calls a method in a specified Contract with the given arguments. Here is to illustrate the details by example of smart contract \"ContractProxy\".</p>","tags":["pchain-sdk","Smart Contract","Cross Contract Call"]},{"location":"smart_contract_sdk/advance/cross_contract/#call-contract-by-using-trait","title":"Call Contract by Using Trait","text":"<p>SDK provides developer-friendly ways to call another contract by using macro <code>use_contract</code>. The address of the contract is specified inside the attribute list in the macro. </p> <pre><code>/// ### Lesson 1:\n/// Use macro `use_contract` to specify the contract action entrypoint methods in a trait.\n/// The address is hard-coded when using the macro `use_contract`.\n/// It is recommended to remove/comment out the methods that are not intended to be used.\n#[use_contract(\"-jUt6jrEfMRD1JM9n6_yAASl2cwsc4tg1Bqp07gvQpU\")]\npub trait MyLittlePony {\n    //fn self_introduction() -&gt; String;\n    fn grow_up();\n    //fn change_person(name :String, age :u32, gender_name :String, description :String);\n}\n</code></pre> <p>In the example above, module <code>my_little_pony</code> is generated which name which is the trait name in a snake case format. Associate methods are generated inside the module for being used to make cross-contract calls.</p> <pre><code>/// ### Lesson 2:\n/// The trait will be transformed to mod by using macro `use_contract`. \n/// Calling the contract `MyLittlePony` can be simply calling associate methods according to the defined method in the trait.\n/// Value and Gas will be needed in cross contract call\n#[call]\nfn grow_up() {\n    my_little_pony::grow_up(0, 120000);\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","Cross Contract Call"]},{"location":"smart_contract_sdk/advance/cross_contract/#call-contract-by-using-function","title":"Call Contract by Using Function","text":"<p>Cross-contract calls can also be simply made by using the function <code>pchain_sdk::call</code> or <code>pchain_sdk::call_untyped</code>.</p> <pre><code>/// ### Lesson 3:\n/// It is also possible to use call_untyped() instead of macro `use_contract` to make a cross contract call.\n/// Address can also be passed as an argument so that the contract address is not necessarily hard-coded.\n#[call]\nfn grow_up_2() {\n    let contract_address = Base64URL::decode(\"-jUt6jrEfMRD1JM9n6_yAASl2cwsc4tg1Bqp07gvQpU\").unwrap().try_into().unwrap();\n    pchain_sdk::call_untyped(\n        contract_address,\n        \"grow_up\", \n        Vec::new(),\n        0);\n}\n</code></pre> <p>Different from using Trait, it no longer requires the address to be hard coded as it can be passed from method arguments.</p>","tags":["pchain-sdk","Smart Contract","Cross Contract Call"]},{"location":"smart_contract_sdk/advance/crypto/","title":"Cryptographic Functions","text":"<p>Cryptographic Function refers to cryptographic functions that are supported from execution runtime so that gas cost can be reduced by avoiding implementation inside a contract. Moreover, It helps in providing complicated calculations which are not feasible in the Wasmer environment (e.g. encryption, hashing).</p> <p>In ParallelChain Mainnet SDK, precompiles are a set of functions that can be called directly. Please be noted that some functions are selected based on the popularity of the blockchain ecosystem, but are not necessary adopted in the implementation of the ParallelChain Mainnet node.</p> Function Description Gas Cost sha256 SHA256 hash function 16 x length of the input keccak256 Keccak-256 hash function 16 x length of the input ripemd RIPEMD-160 hash function 16 x length of the input verify_ed25519_signature Verification on ed25519 signature 1,400,000 + 16 x length of the input <p>The gas consumption is estimated by the compute costs for precompile functions used by developers to deploy smart contracts on ParallelChain Mainnet.</p> <p>To use the functions, include the module <code>crypto</code> and then call the associate methods. For example,</p> <pre><code>use pchain_sdk::crypto;\n\ncrypto::sha256(input);\n</code></pre>","tags":["pchain-sdk","Smart Contract","Cryptographic Functions"]},{"location":"smart_contract_sdk/advance/entrypoints/","title":"Contract Methods","text":"<p>In ParallelChain Smart Contract Programming Model, a contract is like a <code>Rust</code> <code>struct</code> that controls access to persistent storage. Accounts can interact with contracts by submitting transactions that include a call command to invoke methods of the contract. These methods are sometimes called just \"methods\" for short.</p>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"smart_contract_sdk/advance/entrypoints/#methods","title":"Methods","text":"<p>The model defines Contract Methods as methods with the <code>#[call]</code> macro. Each of these corresponds to a method that can be called via a Call Command in the CBI Subprotocol. To allow methods to be called from the outside world, you must write method definitions within an <code>impl Contract</code> statement marked with the <code>#[contract_methods]</code> macro. The following example illustrates this:</p> <pre><code>#[contract_methods]\nimpl PrinceTheDog {\n\n    #[call]\n    pub fn eat_food(&amp;mut self, food: DogFood) -&gt; Poop {\n        // ...\n    }\n}\n</code></pre> <p>Methods can change Contract Storage. However, mutations made in a Call Transaction only apply if the transaction is successful. This means that the transaction must have enough gas, not have panicked during execution, and so on.</p> <p>A function can be called an Action Method only if:</p> <p>The <code>#[call]</code> macro is added above the function declaration. Its arguments (if any) implement <code>BorshDeserialize</code>. Its return value (if any) implements <code>BorshSerialize</code>.</p>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"smart_contract_sdk/advance/entrypoints/#accepting-parameters-and-returning-values","title":"Accepting Parameters and Returning Values","text":"<p>Some of the code snippets provided in this document show Contract Methods that accept arguments (in addition to borrow of the Contract struct) and/or return a value. To enable a contract to receive arguments from and return values to callers, both the contract and the caller need to agree on a serialization format.</p> <p>The <code>pchain-sdk</code> expects callers to serialize method arguments using the Borsh serialization standard. It generates code to serialize values into borsh for inclusion in a Transaction's Receipt. To be precise, a Call Transaction specifies the Contract Method to call and provide the arguments for the call by including a borsh-serialized data structure <code>Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;</code> in its <code>arguments</code> field, and then returning a borsh-serialized value (if any).</p>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"smart_contract_sdk/advance/internal_transaction/","title":"Transferring Balance","text":"<p><code>pchain_sdk::transfer</code> transfers the balance from the Contract Account to another Account and returns the balance of the recipient after the transfer.</p> <pre><code>/// Transfer the balance amount to another address. \nfn transfer(recipient: PublicAddress, amount: u64);\n</code></pre> <p>Notes:</p> <ul> <li>Balance is deducted from the contract, but not the caller's account.</li> <li>Gas cost is deducted from the caller's account.</li> </ul> <p>Example:</p> <pre><code>/// Use method transfer() to send tokens from this contract balance to a specific address.\n#[call]\nfn send_tokens(value :u64){\n    let contract_address = Base64URL::decode(\"-jUt6jrEfMRD1JM9n6_yAASl2cwsc4tg1Bqp07gvQpU\").unwrap().try_into().unwrap();\n    pchain_sdk::transfer(\n        contract_address,\n        value\n    );\n}\n</code></pre>","tags":["mainnet","testnet 4","parallelchain sdk","smart contract","internal transaction"]},{"location":"smart_contract_sdk/advance/params/","title":"Accessing Information about the Blockchain","text":"<p>Contract Methods can be written not only depending on call arguments and the contract's storage, but also on information about the Blockchain, e.g., the previous block hash, or the identity of the External Account that originated the Call Transaction. </p> <p>Functions for getting information about the Transaction that triggered a Contract call and information about the larger Blockchain, in general, are defined in <code>pchain_sdk::transaction</code> and <code>pchain_sdk::blockchain</code> respectively. Internally, these functions are thin wrappers around functions defined in the Imports Set of the Contract ABI.</p>","tags":["pchain-sdk","Smart Contract","transaction"]},{"location":"smart_contract_sdk/advance/params/#parameters-from-blockchain-and-transaction","title":"Parameters from Blockchain and Transaction","text":"<p>Contract execution is triggered by a Call Transaction to the blockchain. The contract being executed can obtain information from this transaction, and also the blockchain during execution. The information can be obtained by calling API methods in <code>pchain_sdk</code>.</p> <p>Example: <pre><code>// Get the timestamp of this block\nlet timestamp = pchain_sdk::blockchain::timestamp();\n</code></pre></p> <p>Related APIs in <code>pchain_sdk::blockchain</code>:</p> <pre><code>/// Get the `block_number` field of the Block that contains the Transaction which triggered this Contract call. \nfn block_number() -&gt; Vec&lt;u8&gt;;\n/// Get the `prev_block_hash` field of the Block that contains the Transaction which triggered this Contract call.\nfn prev_block_hash() -&gt; Vec&lt;u8&gt;;\n/// Get the `timestamp` field of the Block that contains the Transaction which triggered this Contract call.\nfn timestamp() -&gt; u32;\n/// Get the `balance` of the current account.\nfn balance() -&gt; u53;\n</code></pre> <p>Related APIs in <code>pchain_sdk::transaction</code>:</p> <pre><code>/// Get from the address of invoking the transaction\nfn calling_account() -&gt; [u8;32];\n/// Get to the address of invoking the transaction\nfn current_address() -&gt; [u8;32];\n/// Get the value of invoking transaction\nfn amount() -&gt; u64;\n/// Returns whether it is an internal call\nfn is_internal_call() -&gt; bool;\n/// Get transaction hash of invoking transaction\nfn transaction_hash() -&gt; [u8;32];\n/// Get the method name of the invoking Contract Method\nfn method() -&gt; String;\n/// Get method arguments of the invoking Contract Method\nfn arguments() -&gt; Vec&lt;u8&gt;;\n</code></pre>","tags":["pchain-sdk","Smart Contract","transaction"]},{"location":"smart_contract_sdk/advance/staking/","title":"Staking in Contract","text":"<p>Contract address can be used as owner in staking, in other words, to perform staking on behalf of a contract. It is done by invoking a contract call to create Network command(s) (i.e. Create Deposit, TopupDeposit, ... etc) inside the contract method. The execution of these network commands will be deferred after the successful execution of the entire contract call. To create deferred network command, you can call functions <code>defer_*</code> provided by the SDK.</p> <p>Notes:</p> <ul> <li>The owner of the staking is using a contract address.</li> <li>There is no additional command receipt. Failure of deferred network command execution results in failure of the entire contract call. </li> <li>The <code>return values</code> in the final receipt will be overwritten (if any) by the network command.</li> <li>In the cross-contract-call scenario, deferred network command is not executed after the internal contract call, but after the origin contract call.</li> </ul> <p>Related APIs in <code>pchain_sdk::network</code>:</p> <pre><code>/// Instantiation of a Deposit in the state.\nfn defer_create_deposit(operator: PublicAddress, balance: u64, auto_stake_rewards: bool);\n/// Update settings of an existing Deposit.\nfn defer_set_deposit_settings(operator: PublicAddress, auto_stake_rewards: bool);\n/// Increase the balance of an existing Deposit.\nfn defer_topup_deposit(operator: PublicAddress, amount: u64);\n/// Withdraw balance from an existing Deposit.\nfn defer_withdraw_deposit(operator: PublicAddress, max_amount: u64);\n/// Increase stakes to an existing Pool\nfn defer_stake_deposit(operator: PublicAddress, max_amount: u64);\n/// Remove stakes from an existing Pool.\nfn defer_unstake_deposit(operator: PublicAddress, max_amount: u64);\n</code></pre> <p>Check out the Tutorial 6 for the tutorial on using <code>defer</code> calls in smart contracts.</p>","tags":["pchain-sdk","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_1/","title":"Chapter 1","text":"<p>In this chapter, we will go through the steps of creating a simple smart contract with the help of <code>pchain-sdk</code>.</p> <p>Firstly, we have to prepare the <code>Cargo.toml</code>, which specifies the name, version, and year of edition of the smart contract. We need to use <code>pchain-sdk</code> for this smart contract development, so remember to add <code>pchain-sdk = { version = \"LATEST_VERSION\"}</code> under dependencies.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_1/#cargotoml","title":"Cargo.toml","text":"<pre><code>[package]\nname = \"hello_contract\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npchain-sdk = { version = \"LATEST_VERSION\"}\n</code></pre> <p>After preparing <code>Cargol.toml</code>, we can now start preparing the smart contract.  </p> <p><code>#[contract]</code> defines basic struct as a programming model of a contract.  Fields are data representations of contract storage.</p> <p><code>#[contract_methods]</code> defines impl for the contract struct.  Methods declared in the impl are callable by Transaction Command Call if their visibility is <code>pub</code>.</p> <p><code>#[call]</code> macro applies to impl methods for the contract method call. </p> <p>In the file, we have added a method called <code>hello()</code>, <code>pchain_sdk::log()</code> logs the key and value and stores them into a tmp directory when the method is invoked.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_1/#librs","title":"lib.rs","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, storage, log, \n};\n\n#[contract]\nstruct HelloContract {}\n\n#[contract_methods] \nimpl HelloContract {\n\n    #[call]\n    fn hello() {\n        pchain_sdk::log(\n            \"topic: Hello\".as_bytes(), \n            \"Hello, Contract\".as_bytes()\n        );\n    }\n}\n</code></pre> <p>Next, we can add two other methods, which illustrate how we can set or read values from the storage.</p> <pre><code>#[call]\nfn hello_set_many() {\n    for i in 1..10{\n        let key = format!(\"hello-key-{}\", i);\n        let value = vec![0_u8; 1024*10]; //10KB\n        storage::set(key.as_bytes(), &amp;value);\n    }\n}\n\n#[call]\nfn hello_read_many() {\n    for i in 1..10{\n        let key = format!(\"hello-key-{}\", i);\n        let value = storage::get(key.as_bytes());\n        if value.is_some(){\n            log(\n                \"topic: Hello read\".as_bytes(), \n                format!(\"key: {}, len: {}\", key, value.unwrap().len()).as_bytes()\n            );\n        }\n    }\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/","title":"Chapter 2","text":"<p>In Chapter 2, we will implement a smart contract called <code>MyLittlePony</code>, to demonstrate how a contract can:</p> <ul> <li>define entrypoint methods</li> <li>define fields as data in contract storage</li> </ul> <p>From the last chapter, we have learned that the macro <code>contract</code> on struct allows loading or storing fields from or into the world state.  The key to be stored is an u8 integer ordered by the index of the fields.</p> <p>In this chapter, we first create a struct, <code>MyLittlePony</code>, that consists of <code>name</code>, <code>age</code>, and <code>gender</code>. In this case, <code>name</code> has key [0] while <code>age</code> has key [1].</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/#librs-define-mylittlepony","title":"lib.rs: define MyLittlePony","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, contract_field\n};\n\n#[contract]\npub struct MyLittlePony {\n    name: String,\n    age: u32,\n    gender: Gender,\n}\n</code></pre> <p>Next, we need to declare the <code>Gender</code> struct, which is the type of the <code>gender</code> field. To use the nested struct in the contract struct, we need the <code>contract_field</code> macro to access the key-value pair in canonical format. For instance, <code>name</code> in <code>Gender</code> struct has a key [2][0] in the contract <code>MyLittlePony</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/#librs-define-gender","title":"lib.rs: define Gender","text":"<pre><code>#[contract_field]\nstruct Gender {\n    name: String,\n    description: String\n}\n</code></pre> <p>After getting all the structs ready, we should start implementing the contract methods. This smart contract should provide three functionalities:</p> <ul> <li>self_introduction()</li> <li>grow_up()</li> <li>change_pony()</li> </ul> <p>Firstly, <code>self_introduction()</code> uses receiver <code>&amp;self</code> to load all data before executing this method. All data will be loaded to the receiver self from the world state. Therefore, we can have access to all the  fields in the contract, including the fields in the <code>Gender</code> struct.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/#librs-load-data-with-self","title":"lib.rs: load data with &amp;self","text":"<pre><code>#[contract_methods]\nimpl MyLittlePony {\n\n    #[call]\n    fn self_introduction(&amp;self) -&gt; String {\n        format!(\"Hi, I am {}. Age of {}. I am {} that means {}.\",\n            self.name, self.age, self.gender.name, self.gender.description)\n    }\n}\n</code></pre> <p>In the next method, we are going to illustrate how we can use contract getter and setter to obtain/store data from or to the world state. Write cost is smaller compared to what we did in <code>self_introduction()</code> because there is only one key-value pair in the world state to be mutated.</p> <p>Instead of passing <code>&amp;self</code> as an argument, simply do <code>Self::get_&lt;field_name&gt;()</code> to obtain value and  <code>Self::set_&lt;field_name&gt;()</code> to store updated value.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/#librs-getter-and-setter","title":"lib.rs: getter and setter","text":"<pre><code>#[call]\nfn grow_up() {\n    let age = Self::get_age();\n    Self::set_age(age+1)\n}\n</code></pre> <p>Lastly, we want to change our little pony, so we use a mutable receiver <code>&amp;mut self</code> to load data before executing this method, then store all data after execution. However, we should be cautious when using a mutable receiver as it is expensive to load and store since it mutates all key-value pairs in the world state.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_2/#librs-load-data-with-a-mutable-receiver","title":"lib.rs: load data with a mutable receiver","text":"<pre><code>#[call]\nfn change_pony(&amp;mut self, name: String, age: u32, gender_name: String, description: String) {\n    pchain_sdk::log(\n        \"update_gender\".to_string().as_bytes(), \n        format!(\"update name:{} description: {}\", name, description).as_bytes());\n    self.name = name;\n    self.age = age;\n    self.gender.name = gender_name;\n    self.gender.description = description;\n}\n</code></pre> <p>Now you should have learned how to get and set contract fields in your smart contract.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/","title":"Chapter 3","text":"<p>We have introduced macros including <code>contract</code>, <code>contract methods</code>, and <code>call</code> in Chapter 1 and accessing values of fields from storage in Chapter 2. In this chapter, we will put together all the knowledge and implement the bank smart contract that simulates banking operations with data stored in ParallelChain Mainnet. </p> <p>Before diving into the writing of a smart contract, let's build the data struct <code>BankAccount</code> using the <code>sdk_method_bindgen</code> macro provided by Parallelchain Mainnet Smart Contract SDK.</p> <p><code>bank_account.rs</code> defined the <code>BankAccount</code> data struct which consists of four fields, <code>first_name</code>, <code>last_name</code>, <code>account_id</code>, and <code>amount</code>. All these fields will be initialized to 0 or empty upon deployment.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#bank_accountrs-define-data-struct","title":"bank_account.rs: define data struct","text":"<pre><code>use borsh::{BorshDeserialize, BorshSerialize};\n\nuse pchain_sdk::{\n    storage,\n};\n\n// Note that both the serializer and deserializer macros such as Borsh need to \n// be applied to this struct for it to work.\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct BankAccount {\n    pub first_name: String,\n    pub last_name: String,\n    pub account_id: String,\n    pub amount: u64,\n}\n</code></pre> <p>After defining the data struct, add the following two functions which are responsible for loading and storing the value with a given key accordingly. </p> <p>Note The key to be stored is an u8 integer ordered by the index of the fields, e.g. <code>first_name</code> has key [0].</p> <p><code>get_bank_account()</code> retrieve the value of the given key using <code>pchain_sdk::storage::get()</code>, deserialize the result and return an <code>Option</code>.</p> <p><code>set_bank_account()</code> stores the given key-value pair in the storage using  <code>pchain_sdk::storage::set()</code>.</p> <p>We are using BorshDeserialize and BorshSerialize in the above code, so remember to update the Cargo.toml by adding the borsh crate. We need the base64 crate for encoding the account_id too. Therefore, add the following two lines under the dependencies section in Cargo.toml:</p> <ul> <li>base64 = \"0.13\"</li> <li>borsh = \"=0.10.2\"</li> </ul>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#bank_accountrs-accessing-storage","title":"bank_account.rs: accessing storage","text":"<pre><code>pub fn get_bank_account(key: &amp;[u8]) -&gt; Option&lt;BankAccount&gt; {\n    match storage::get(key) {\n        Some(raw_result) =&gt; {\n            let p: Option&lt;BankAccount&gt; =\n                match BorshDeserialize::deserialize(&amp;mut raw_result.as_ref()) {\n                    Ok(d) =&gt; Some(d),\n                    Err(_) =&gt; None,\n                };\n            p\n        }\n        None =&gt; None,\n    }\n}\n\npub fn set_bank_account(key: &amp;[u8], value: &amp;BankAccount) {\n    let mut buffer: Vec&lt;u8&gt; = Vec::new();\n    value.serialize(&amp;mut buffer).unwrap();\n    storage::set(key, buffer.as_ref());\n}\n</code></pre> <p>Lastly, add the impl of <code>BankAccount</code> which includes two methods that perform the actions of deposit and withdrawal.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#bank_accountrs-impl-methods","title":"bank_account.rs: impl methods","text":"<pre><code>impl BankAccount {\n    pub fn deposit_to_balance(&amp;mut self, amount_to_add: u64) {\n        self.amount += amount_to_add;\n    }\n    pub fn withdraw_from_balance(&amp;mut self, amount_to_withdraw: u64) -&gt; Option&lt;u64&gt; {\n        if amount_to_withdraw &lt;= self.amount {\n            self.amount -= amount_to_withdraw;\n            Some(self.amount)\n        } else {\n            None\n        }\n    }\n}\n</code></pre> <p>After having the <code>BankAccount</code> struct ready, it is time to start writing the bank smart contract. <code>use bank_account::BankAccount;</code> allows us to use the methods defined in <code>bank_account.rs</code>.</p> <p>The macro <code>contract</code> on the data struct allows loading/storing fields from/into the world state. The contract struct, <code>MyBank</code>, has only one field, <code>num_of_account</code>, indicating the number of accounts associated with this bank. As mentioned in the previous section, the key of <code>num_of_account</code> in the storage will be [0] according to its index.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#librs-define-contract-struct","title":"lib.rs: define contract struct","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, crypto\n};\n\nmod bank_account;\n\nuse bank_account::BankAccount;\n\n#[contract]\nstruct MyBank {\n    num_of_account: u64\n}\n</code></pre> <p>As mentioned in Chapter 1, the macro <code>#[contract_methods]</code> generates entrypoint methods that can be called in transaction. We will create the first entrypoint method in <code>MyBank</code> impl. Firstly, we need the entrypoint method <code>open_account()</code> to create a brand-new account, with the specified <code>first_name</code>, <code>last_name</code>, <code>account_id</code>, and <code>initial_deposit</code>.</p> <p>In <code>open_account()</code>, we initialize an instance of <code>BankAccount</code>, and store it in the storage directly by invoking <code>bank_account::set_bank_account</code>. </p> <p>After storing the newly generated account into storage, we have to update the <code>num_of_account</code>. Therefore, we obtain the value of the field by doing <code>MyBank::get_num_of_account()</code>, like how we get the fields of our pony in Chapter 2. Similarly, store the updated value by calling <code>MyBank::set_num_of_account()</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#librs-open-a-new-account","title":"lib.rs: open a new account","text":"<pre><code>#[contract_methods]\nimpl MyBank {\n\n    /// entrypoint method \"open_account\"\n    #[call]\n    fn open_account(\n        first_name: String,\n        last_name: String,\n        account_id: String,\n        initial_deposit: u64,\n    ) {\n        let parsed_account_id= \n        if account_id != \"\" {\n            account_id.to_owned().as_bytes().to_vec()\n        } else {\n\n            // Generate a new account id using the base64 encoded sha256 hash\n            // of the first and last name concatenated together\n\n            let input = format!(\"{}{}\", &amp;first_name, &amp;last_name).to_string().as_bytes().to_vec();\n            crypto::sha256(input)\n        };\n\n        // Create a new instance of BankAccount\n        let opened_bank_account = BankAccount {\n            first_name: first_name.to_owned(),\n            last_name: last_name.to_owned(),\n            account_id:  base64::encode(parsed_account_id),\n            amount: initial_deposit,\n        };\n\n        // Calling the functions from bank_account.rs\n        bank_account::set_bank_account(\n            &amp;opened_bank_account.account_id.as_bytes(),\n            &amp;opened_bank_account\n        );\n\n        let initial_num_of_account = MyBank::get_num_of_account();\n        MyBank::set_num_of_account(initial_num_of_account + 1);\n\n        pchain_sdk::log(\n            \"bank_account: Open\".as_bytes(),\n            format!(\"Successfully opened \n            account for {}, {} \n            with account_id: {}\",\n            &amp;opened_bank_account.first_name,\n            &amp;opened_bank_account.last_name,\n            &amp;opened_bank_account.account_id).as_bytes()\n        );\n    }\n}\n</code></pre> <p>Now, we have successfully created a function that creates a new bank account, we should support other basic banking functionalities.</p> <p>Let's start with checking account balance, users need to know how much money is left in their accounts.</p> <p>By calling <code>bank_account::get_bank_account()</code> with a given <code>account_id</code>, <code>Option&lt;BankAccount&gt;</code> will be returned. If  <code>None</code> is returned, the account does not exist; otherwise, we will be able to obtain the balance of the account by  accessing the value of the field <code>amount</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#librs-query-account-balance","title":"lib.rs: query account balance","text":"<pre><code>#[call]\nfn query_account_balance(account_id: String) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(balance) =&gt; {\n            pchain_sdk::log(\n                format!(\"bank: query_account_balance\").as_bytes(),\n                format!(\n                    \"The current balance is: {}\", \n                    &amp;balance.amount\n                ).as_bytes()\n            );\n        },\n        None =&gt; {\n            pchain_sdk::log(\n                format!(\"bank: query_account_balance\").as_bytes(),\n                format!(\"No such account found\").as_bytes()\n            );\n        }\n    }\n}\n</code></pre> <p>Lastly, finish up the functionalities of the bank by completing the implementation of <code>withdraw_money()</code> and  <code>deposit_money</code> using the methods mentioned in all previous sections.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_3/#librs-withdrawal-and-deposit","title":"lib.rs: withdrawal and deposit","text":"<pre><code>#[call]\nfn withdraw_money(account_id: String, amount_to_withdraw: u64) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(mut query_result) =&gt; {\n            match query_result.withdraw_from_balance(amount_to_withdraw) {\n                Some(balance) =&gt; {\n\n                    // update the world state\n                    bank_account::set_bank_account(account_id.as_bytes(), &amp;query_result);\n\n                    pchain_sdk::log(\n                        format!(\"bank: withdraw_money\").as_bytes(),\n                        format!(\"The updated balance is: \\n\n                        Name: {} {}\\n\n                        Account Number: {}\\n\n                        Balance: {}\", \n                        &amp;query_result.first_name,\n                        &amp;query_result.last_name,\n                        &amp;query_result.account_id,\n                        &amp;balance).as_bytes()\n                    );\n                }\n                None =&gt; pchain_sdk::log(\n                    format!(\"bank: withdraw_money\").as_bytes(),\n                    format!(\"You do not have enough funds to withdraw from this account.\").as_bytes()\n                ),\n            }\n        },\n        None =&gt; pchain_sdk::log(\n            format!(\"bank: withdraw_money\").as_bytes(),\n            format!(\"No such account found\").as_bytes()\n        ),\n    };\n}\n</code></pre> <pre><code>#[call]\nfn deposit_money(account_id: String, amount_to_deposit: u64) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(mut query_result) =&gt; {\n            query_result.deposit_to_balance(amount_to_deposit);\n\n            // update the world state\n            bank_account::set_bank_account(account_id.as_bytes(), &amp;query_result);\n\n            pchain_sdk::log(\n                format!(\"bank: deposit_money\").as_bytes(),\n                format!(\"The updated balance is: \\nName: {} {}\\nAccount Number: {}\\nBalance: {}\", \n                &amp;query_result.first_name,\n                &amp;query_result.last_name,\n                &amp;query_result.account_id,\n                &amp;query_result.amount).as_bytes()\n            );\n        },\n        None =&gt; pchain_sdk::log(\n            format!(\"bank: query_account_balance\").as_bytes(),\n            format!(\"No such account found\").as_bytes()\n        ),\n    };\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_4/","title":"Chapter 4","text":"<p>This chapter introduces the use of the <code>use_contract</code> macro to interact with other contracts.  We have <code>ContractProxy</code> that serves as a middle-man to another contract <code>MyLittlePony</code>, the contract that we implemented in the last chapter. We are going to explore the interaction between  the two contracts by calling entrypoint methods and sending tokens from the balance of one contract  to another contract.</p> <p>Firstly, use the macro <code>use_contract</code> to specify the contract entrypoint methods in a trait. The address is hard-coded when using this macro. It is recommended to remove or comment out  the methods that are not intended to be used. </p> <p>Recall that we have a deployed contract called <code>MyLittlePony</code> that consists of three methods, <code>self_introduction()</code>, <code>grow_up()</code>, and <code>change_person()</code>. We are going to use <code>grow_up()</code> in  <code>ContractProxy</code>, so we can comment out the rest of them. </p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_4/#librs-define-a-trait","title":"lib.rs: define a trait","text":"<pre><code>use pchain_sdk::{\n    use_contract, call, contract, contract_methods\n};\n\n#[use_contract(\"-jUt6jrEfMRD1JM9n6_yAASl2cwsc4tg1Bqp07gvQpU\")]\npub trait MyLittlePony {\n    //fn self_introduction() -&gt; String;\n    fn grow_up();\n    //fn change_person(name: String, age: u32, gender_name: String, description: String);\n}\n</code></pre> <p>After preparing the trait <code>MyLittlePony</code>, we start implementing the functionalities of <code>ContractProxy</code>.</p> <p>The trait will be transformed to mod by using the macro <code>use_contract</code>, Calling the contract <code>MyLittlePony</code> can be simply calling associate methods according to the defined method in the trait. One way of calling  <code>grow_up()</code> is to simply do <code>my_little_pony::grow_up(0)</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_4/#librs-use_contract-macro","title":"lib.rs: use_contract macro","text":"<pre><code>#[contract]\npub struct ContractProxy {}\n\n#[contract_methods]\nimpl ContractProxy {\n\n    #[call]\n    fn grow_up() {\n        my_little_pony::grow_up(0);\n    }\n}\n</code></pre> <p>The above example has shown how we can use the <code>use_contract</code> macro to do cross-contract calls. It is also possible to use <code>pchain_sdk::call_untyped()</code> to do so. We pass the contract address as an argument so that the contract address does not need to be hard-coded in the contract.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_4/#librs-pchain_sdkcall_untyped","title":"lib.rs: pchain_sdk::call_untyped()","text":"<pre><code>#[call]\nfn grow_up_2(address: String) {\n    let contract_address = base64url::decode(address).unwrap().try_into().unwrap();\n    pchain_sdk::call_untyped(\n        contract_address,\n        \"grow_up\", \n        Vec::new(),\n        0\n    );\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_4/#librs-transfer-contract-balance","title":"lib.rs: transfer contract balance","text":"<p>Except by calling the entrypoint methods from <code>MyLittlePony</code>, we can also transfer the balance from the  contract to a specific address by <code>pchain_sdk::transfer()</code>.</p> <pre><code>#[call]\nfn send_tokens(to_address: String, value :u64){\n    let contract_address = base64url::decode(to_address).unwrap().try_into().unwrap();\n    pchain_sdk::transfer(\n        contract_address,\n        value\n    );\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"smart_contract_sdk/tutorial/chapter_5/","title":"Chapter 5","text":"<p>tags:   - pchain-sdk   - tutorial   - Smart Contract</p>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#chapter-5","title":"Chapter 5","text":"<p>In the previous chapters, we have understood how we write contract methods and access storage in the world state. In this chapter, we are going to demonstrate the functionality of collections provided by <code>pchain-sdk</code>.</p> <p><code>pchain-sdk</code> provides several collection structures that are designed for gas efficiency:</p> <ul> <li>Cacher: allows lazy initialization</li> <li>Vector: lazily stores a list of items</li> <li>FastMap: lazily stores items into a key-value map</li> <li>IterableMap: lazily stores items into an iterable key-value map</li> </ul> <p>We create the <code>MyCollections</code> struct which includes all these collection structures.</p>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#librs","title":"lib.rs","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, Cacher, collections::{Vector, FastMap, IterableMap}\n};\n\ntype Address = [u8; 32];\n\n#[contract]\npub struct MyCollections {\n    lazy_cat: Cacher&lt;String&gt;,\n    pretty_numbers: Vector&lt;i32&gt;,\n    address_resolver: FastMap&lt;Address, String&gt;,\n    prices: IterableMap&lt;String, u32&gt;\n}\n</code></pre>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#cacher","title":"Cacher","text":"<p><code>Cacher</code> is a data wrapper to support Lazy Read and Lazy Write to Contract Storage.</p> <pre><code>#[contract_methods]\nimpl MyCollections {\n\n    /// Here we use the receiver `&amp;self` without loading data before executing this method. \n    #[call]\n    fn meow(&amp;self) -&gt; String {\n        // Actual loading happens here. \n        // Dereference as immutable and invoke a function as &amp;String\n        self.lazy_cat.to_uppercase()\n    }\n\n    /// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n    #[call]\n    fn feed(&amp;mut self, data: String) {\n        // Dereference as mutable and then assign a value to it\n        self.lazy_cat.set(data);\n        // Actual saving happens after this method\n    }\n}\n</code></pre>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#vector","title":"Vector","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn pick(&amp;self, index: usize) -&gt; Option&lt;i32&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from iterator\n    self.pretty_numbers.iter().nth(index).map(|value| *value)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn push(&amp;mut self, num: i32) -&gt; usize {\n    // Dereference as mutable and then set a value to it\n    self.pretty_numbers.push(&amp;num);\n    self.pretty_numbers.len()\n    // Actual saving happens after this method\n}\n</code></pre>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#fastmap","title":"FastMap","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn resolve(&amp;self, address: Address) -&gt; Option&lt;String&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from key-value map\n    self.address_resolver.get(&amp;address)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn add_record(&amp;mut self, address: Address, name: String) {\n    // Dereference as mutable and then insert a value\n    self.address_resolver.insert(&amp;address, name)\n    // Actual saving happens after this method\n}\n</code></pre>"},{"location":"smart_contract_sdk/tutorial/chapter_5/#iterablemap","title":"IterableMap","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn price(&amp;self, item: String) -&gt; Option&lt;u32&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from key-value map\n    self.prices.get(&amp;item)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn set_price(&amp;mut self, item: String, price: u32) {\n    // Dereference as mutable and then insert a value\n    self.prices.insert(&amp;item, price);\n    // Actual saving happens after this method\n}\n\n/// This method the iterable-map to calculate the sum of the values by iterating each item.\n#[call]\nfn total_price(&amp;self) -&gt; u32 {\n    self.prices.values().sum()\n}\n</code></pre>"},{"location":"smart_contract_sdk/tutorial/chapter_6/","title":"Chapter 6 - Network Commands","text":"<p>In the last chapter of the tutorial, we are going to talk about how to use network commands in smart contracts. </p> <p>In ParallelChain Mainnet, there are six different network commands: - Create deposit - Set deposit settings - Top-up deposit - Withdraw deposit - Stake deposit - Unstake deposit</p> <p>We will demonstrate how the above network commands can be created and sent to  the network through the use of a smart contract. We will use the contract, <code>MyPool</code>  to guide you through the steps of creating a stake in a pool with the network commands.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-define-a-struct","title":"lib.rs: define a struct","text":"<p><pre><code>use pchain_sdk::{\n    call, contract, contract_methods\n};\n\ntype Address = [u8;32];\n\n#[contract]\npub struct MyPool {\n    pool_operator: Address,\n    my_friend: Address\n}\n</code></pre> We have created the struct <code>MyPool</code>, which consists of the addresses of the <code>pool_operator</code> and <code>my_friend</code>. However, as mentioned in previous chapters, it will be initialized to 0 upon deployment. Therefore, we have to add an init function to initialize the address to the values we specified.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-initialise-struct","title":"lib.rs: initialise struct","text":"<pre><code>#[contract_methods]\nimpl MyPool {\n\n    #[call]\n    fn init(pool_operator: Address, my_friend: Address){\n        MyPool { pool_operator, my_friend }.set();\n    } \n\n}\n</code></pre> <p>After adding the <code>init()</code> function, we can try creating a deposit into the pool. <code>pchain_sdk::network:defer_create_deposit()</code> allows us to deposit some XPLL into a specified pool. In this contract, we have already specified the pool in the field <code>pool_operator</code>.</p> <p>The network commands are \"deferred\" because the actual execution of such commands occurs after the execution of a successful call. </p> <p>Note:  The deposit is created on behalf of the contract address, not from your account address, so make sure to transfer sufficient balance to the contract for the operation.</p> <p>To check if the deposit is successful, you can check the deposit using <code>pchain-client</code> with the following command:</p> <p>./pchain_client query deposit --operator  --owner","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-successful-network-command","title":"lib.rs: successful network command","text":"<pre><code>    #[call]\n    fn create_deposit(balance: u64, auto_stake_rewards: bool) {\n        pchain_sdk::network::defer_create_deposit(Self::get_pool_operator(), balance, auto_stake_rewards)\n    }\n</code></pre> <p>It was mentioned above that the <code>defer</code> call will only take place after a successful call. Here, we are making the transaction fail deliberately by transferring more than what we have in balance. As a result, the transaction call will fail, and the stake should not be deposited. </p> <p>Check the deposit again using <code>pchain-client</code>, the deposit balance in the pool should remain unchanged.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-failed-network-command","title":"lib.rs: failed network command","text":"<pre><code>    #[call]\n    fn transfer_too_much() {\n        let balance = pchain_sdk::blockchain::balance();\n        pchain_sdk::transfer(Self::get_my_friend(), balance + 1);\n        pchain_sdk::network::defer_stake_deposit(Self::get_pool_operator(), balance);\n    }\n</code></pre> <p>Another characteristic of the network commands is that the return value in the transaction receipt will be overwritten by the deferred staking commands. </p> <p>In the method <code>stake_deposit()</code>, we should be expecting that the <code>return_values</code> in the receipt will be the  balance of the contract. However, since there is a defer network command in the method call, the <code>return_values</code> will be overwritten by the return value from the <code>pchain_sdk::network::defer_staking_deposit()</code> command.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-overwriting-return-value","title":"lib.rs: overwriting return value","text":"<pre><code>    #[call]\n    fn stake_deposit(max_amount: u64) -&gt; u64{\n        pchain_sdk::network::defer_stake_deposit(Self::get_pool_operator(), max_amount);\n        pchain_sdk::blockchain::balance()\n    }\n</code></pre> <p>Lastly, we can include multiple network commands within one transaction. In this <code>multiple_defer()</code> function, we put the commands for unstaking and withdrawing deposits in the same function.</p> <p>Both the commands will be executed after the success of the transaction, and in the order they were called in the method call. After invoking this method call, the stake of the deposit should have been successfully withdrawn.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"smart_contract_sdk/tutorial/chapter_6/#librs-multiple-network-commands","title":"lib.rs: multiple network commands","text":"<pre><code>    #[call]\n    fn multiple_defer(max_amount: u64) {\n        let operator = Self::get_pool_operator();\n        pchain_sdk::network::defer_unstake_deposit(operator, max_amount);\n        pchain_sdk::network::defer_withdraw_deposit(operator, max_amount);\n    }\n</code></pre> <p>Congratulations! You have completed all tutorials and are ready to write your smart contract!</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"toolings/pchain_client_rust/","title":"pchain-cli-rust","text":"<p>pchain-cli-rust is a Rust client library for the ParallelChain Protocol fullnode RPC API.</p> <p>It is designed to be user-friendly and accessible to developers and non-developers alike. It is intended to provide a simple and intuitive way to interact with the blockchain network, without requiring extensive technical knowledge or expertise.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_client_rust/#getting-started","title":"Getting started","text":"<p>Get started by creating an instance of client. </p> <pre><code>use pchain_client::Client;\n\nlet client = Client::new(\"https://rpc_base_url.xyz\");\n</code></pre> <p>You will then be able to access each RPC through a corresponding method of the same name.</p> <pre><code>client.submit_transaction(txn);\nclient.block(block_request);\nclient.state(state_request);\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/install_and_setup/","title":"Install and Setup","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/install_and_setup/#installation","title":"Installation","text":"<p><code>pchain_client</code> is an available tool for users on Unix/Linux, MacOS, and Windows operating systems. Simply download the pre-built binary corresponding to your platform and install the <code>pchain_client</code>.</p> <p>Here are the simple steps to install <code>pchain_client</code>:</p> <ul> <li>Open a web browser and go to release page.</li> <li>Follow the link to download pre-built binary available for your platform.</li> <li>Run the downloaded file.</li> </ul> <p>NOTE: If this is your first time using <code>pchain_client</code>, you need to setup <code>$PCHAIN_CLI_HOME</code> in environment variables to specify the home path. See more here.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/install_and_setup/#running-pchain_client","title":"Running pchain_client","text":"<p>Upon first use of <code>pchain_client</code>, you will be prompted to set up a password to protect your account keypairs. Please note that this password can be different from the password you used in ParallelChain Explorer. Alternatively, you can skip the password protection by simply pressing Enter.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client --version\n</code></pre> <pre><code>./pchain_client.exe --version\n</code></pre> <p>You will be required to enter your password twice. If your password is set successfully, you will see a return message with <code>pchain_client</code> version shown on console.</p> <p>WARNING: The password is not sent and saved anywhere. You won't be able to recover the password if you lose it. Please keep your password safe. You will be required to provide this password to submit transactions and manage keypairs later.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/install_and_setup/#prepare-environment","title":"Prepare Environment","text":"<p>Before you can submit transactions or query information on ParallelChain, you need to setup your own choice of ParallelChain RPC API provider URL.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client config setup --url &lt;URL&gt;\n</code></pre> <pre><code>./pchain_client.exe config setup --url &lt;URL&gt;\n</code></pre> <p>This would check the status of your chosen provider. If <code>pchain_client</code> cannot connect to your provider, a warning message will be shown, and setup fails. You need to set up another url with the above command again.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/introduction/","title":"ParallelChain Client CLI (pchain-client)","text":"<p><code>pchain_client</code> is an easy-to-use, fully-featured CLI for interacting with ParallelChain.  For a detailed description of all available commands, execute <code>pchain_client --help</code>. </p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/introduction/#usage","title":"Usage","text":"<pre><code>ParallelChain Client CLI 0.4.3\n&lt;ParallelChain Lab&gt;\nParallelChain client (`pchain_client`) is a command-line tool for you to connect and interact with\nthe ParallelChain Mainnet/Testnet.\n\nUSAGE:\n    pchain_client &lt;SUBCOMMAND&gt;\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    transaction    Construct and submit Transactions to ParallelChain network\n    query          Query blockchain and world state information for ParallelChain network\n    keys           Locally stores and manage account keypairs you created. (Password required)\n    parse          Utilities functions to deserialize return values in CommandReceipt, and\n                       compute contract address\n    config         Get and set Fullnode RPC url to interact with ParallelChain\n    help           Print this message or the help of the given subcommand(s)\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/introduction/#why-pchain_client","title":"Why pchain_client","text":"<p><code>pchain_client</code> allows you to query data from the ParallelChain, submit transactions, and more, all at the comfort of your command line. Check out the examples below for details or see the full list of commands. The following document walks through the CLI's essential workflows. </p> <p>New users can begin either by </p> <ol> <li>Install and Setup or,</li> <li>Prepare Environment or,</li> <li>Setting up New Account</li> </ol> <p>If you are lost at any step, you can always type <code>pchain_client --help</code>.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/introduction/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Install and Setup</li> <li>Installation</li> <li>Running pchain_client</li> <li>Prepare Environment</li> <li>Manage Account</li> <li>Generate new keypair</li> <li>Import existing keypair</li> <li>List accounts</li> <li>Transaction</li> <li>Prepare Transaction file<ul> <li>Create new Transaction file</li> <li>Append Command to existing file</li> </ul> </li> <li>Submit Transaction to ParallelChain</li> <li>Query</li> <li>Check Account related information</li> <li>Get Transaction with receipt</li> <li>Get Deposit and Stake</li> <li>Smart Contract</li> <li>Retrieve contract address</li> <li>Prepare contract method arguments file</li> </ul>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/introduction/#opening-an-issue","title":"Opening an Issue","text":"<p>Open an issue in GitHub if you:</p> <ol> <li>Have a feature request / feature idea,</li> <li>Have any questions (particularly software related questions),</li> <li>Think you may have discovered a bug.</li> </ol> <p>Please try to label your issues appropriately.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/manage_account/","title":"Manage Account","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/manage_account/#manage-account","title":"Manage Account","text":"<p>In ParallelChain, an account is identified by the public key of Ed25519 keypair. You can either generate new keys or import your existing Ed25519 keypair to make transactions in <code>pchain_client</code>. Both operations require password (if you setup before).</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/manage_account/#generate-new-keypair","title":"Generate New Keypair","text":"<p>This command generates a set of ed25519_dalek compatible keys. Random name will be set if you do not provide a name.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys create --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys create --name &lt;NAME&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/manage_account/#import-existing-keypair","title":"Import Existing Keypair","text":"<p>If you have already got keys from ParallelChain Explorer, you can import your account keypair with this command. Random name will be set if you do not provide a name.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys import --private &lt;PRIVATE_KEY&gt; --public &lt;PUBLIC_KEY/ADDRESS&gt; --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys import --private &lt;PRIVATE_KEY&gt; --public &lt;PUBLIC_KEY/ADDRESS&gt; --name &lt;NAME&gt;\n</code></pre> <p><code>PRIVATE_KEY</code> and <code>PUBLIC_KEY/ADDRESS</code> are Base64url encoded.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/manage_account/#list-accounts","title":"List Accounts","text":"<p>After creating or adding keypair, you can check it using the following command to list out all public keys managed in this tool.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys list\n</code></pre> <pre><code>./pchain_client.exe keys list\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/query/","title":"Query","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/query/#query","title":"Query","text":"<p><code>pchain_client</code> allows you to query different data from the ParallelChain, not just Transaction or Account related information, but also details of Validators and Stake Pool in ParallelChain network. </p> <p>Use <code>pchain_client query --help</code> to check the full list available to query.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/query/#check-account-related-information","title":"Check Account Related Information","text":"<p>To check Externally Owned Accounts (EOA) information such as balance and nonce, your account address (public key) is always needed.</p> <p>Commands:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query balance --address &lt;ADDRESS&gt;\n./pchain_client query nonce --address &lt;ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query balance --address &lt;ADDRESS&gt;\n./pchain_client.exe query nonce --address &lt;ADDRESS&gt;\n</code></pre> <p>For Contract Account, you can use another command to download the contract code binary file (wasm).</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query contract --address &lt;ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query contract --address &lt;ADDRESS&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/query/#get-transaction-with-receipt","title":"Get Transaction with Receipt","text":"<p>In Submit Transaction to ParallelChain section, after you successfully make transaction on ParallelChain, you should receive the transaction hash (tx_hash) in the response. This hash is the identity of your transaction. You can always retrieve the transaction details with receipt by the transaction hash.</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query tx --hash &lt;TX_HASH&gt;\n</code></pre> <pre><code>./pchain_client.exe query tx --hash &lt;TX_HASH&gt;\n</code></pre> <p>If you just want to get the receipt, you can use following command</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query receipt --hash &lt;TX_HASH&gt;\n</code></pre> <pre><code>./pchain_client.exe query receipt --hash &lt;TX_HASH&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/query/#get-deposit-and-stake","title":"Get Deposit and Stake","text":"<p>You can query deposit or stake amount of an account from a specific pool stored in Network Account.</p> <p>Commands:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query deposit --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n./pchain_client query stake --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n</code></pre> <pre><code>./pchain_client.exe query deposit --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n./pchain_client.exe query stake --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/smart_contract/","title":"Smart Contract","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/smart_contract/#smart-contract","title":"Smart Contract","text":"<p>Smart contracts are computer programs that are stored on a blockchain. You need to provide some necessary information such as contract address, method name, and arguments in order to invoke method of the contract.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/smart_contract/#retrieve-contract-address","title":"Retrieve Contract Address","text":"<p>After you deploy the contract in a transaction, you should receive the contract address together with transaction hash. If you want to deploy contract and call method in the SAME transaction, it is possible to compute the contract address in advance.</p> <p>You need to provide the account address and nonce when deploying the contract.</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client parse contract-address --address &lt;ADDRESS&gt; --nonce &lt;NONCE&gt;\n</code></pre> <pre><code>./pchain_client.exe parse contract-address --address &lt;ADDRESS&gt; --nonce &lt;NONCE&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/smart_contract/#prepare-contract-method-arguments-file","title":"Prepare Contract Method Arguments File","text":"<p>When you make a contract call that modifies or views state, the contract method may expect arguments. You need to provide arguments by JSON file(.json) with <code>transaction create call</code> or <code>query view</code> commands.</p> <p>Example: For a contract method that accepts 3 arguments (String, Vec , boolean) <pre><code>{\n    \"arguments\": [\n        {\"argument_type\": \"String\", \"argument_value\": \"Yuru Camp\"},\n        {\"argument_type\": \"Vec&lt;i16&gt;\", \"argument_value\":\"[-1, 20]\"},\n        {\"argument_type\": \"bool\", \"argument_value\": \"true\"}\n    ]\n}\n</code></pre> Each object in an arguments array consists of two fields, <code>argument_type</code> and <code>argument_value</code>. Here are some acceptable types and values. Type Description Example <code>i8</code> The 8-bit signed integer type \"-128\" <code>i16</code> The 16-bit signed integer type \"-32768\" <code>i32</code> The 32-bit signed integer type \"-2147483648\" <code>i64</code> The 64-bit signed integer type \"-9223372036854775808\" <code>u8</code> The 8-bit unsigned integer type \"255\" <code>u16</code> The 16-bit unsigned integer type \"65535\" <code>u32</code> The 32-bit unsigned integer type \"4294967295\" <code>u64</code> The 64-bit unsigned integer type \"18446744073709551615\" <code>String</code> String \"\\\"This is test string\\\"\" <code>bool</code> Boolean \"true\" or \"false\" <code>Vec&lt;TYPE&gt;</code> Array with specific type and arbitrary length \"[65535,6535]\" , \"[true,false,true]\" <code>[5]</code> Array with specific length \"[1,2,3,4,5]\"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/","title":"Create Transaction","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/#transaction","title":"Transaction","text":"<p>A transaction is a digitally signed instruction that tells the ParallelChain state machine to execute a sequence of commands. There are different kinds of Commands in ParallelChain protocol. </p> <p><code>pchain_client</code> accepts transaction in json format. This section will demonstrate how to prepare your transaction file and submit it with your account keys.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/#prepare-transaction-file","title":"Prepare Transaction File","text":"<p><code>pchain_client</code> provides user-friendly way to prepare your transaction file without prior knowledge of JSON (JavaScript Object Notation) format. The transaction file consists of 2 parts: <code>Parameters</code> and <code>Subcommand</code>.</p> <p>Here are some CLI subcommands to indicate corresponding Protocol Transaction Command. </p> Subcommand Action Description transfer Transfer balance from transaction signer to recipient deploy Deploy smart contract to the state of the blockchain call Trigger method call of a deployed smart contract deposit Deposit some balance into the network account create Instantiation of a Deposit of an existing Pool top-up Increase balance of an existing Deposit withdraw Withdraw balance from an existing Deposit update-settings Update settings of an existing Deposit stake Stake to a particular pool stake Increase stakes to an existing Pool unstake Remove stakes from an existing Pool pool Create and manage Pool create Instantiation of a Pool in the network account update-settings Update settings of an existing Pool delete Delete an existing Pool in the network account","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/#create-new-transaction-file","title":"Create New Transaction File","text":"<p><code>Transaction</code> in ParallelChain protocol specifies a set of parameters included in the instruction. You don't need to provide all parameters, some of them would be computed and filled in automatically when you submit the transaction.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create --help\n</code></pre> <pre><code>./pchain_client.exe transaction create --help\n</code></pre> <p>First, provide the following 4 parameters:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n  --nonce &lt;NONCE&gt; \\\n  --gas-limit &lt;GAS_LIMIT&gt; \\\n  --max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n  --priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\n...\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n  --nonce &lt;NONCE&gt; `\n  --gas-limit &lt;GAS_LIMIT&gt; `\n  --max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n  --priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\n...\n</code></pre> <p>Then, decide the transaction type using the CLI subcommand. Each of them takes different inputs. You can always check the help menu using <code>--help</code>.</p> <p>Make sure you provide both <code>Parameters</code> and <code>Subcommand</code> parts in one command. The output transaction file (tx.json) will be saved in the current directory. You can also specify the designated file with the flag <code>--destination</code></p> <p>Example - Transfer tokens:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n  --nonce 0 \\\n  --gas-limit 100000 \\\n  --max-base-fee-per-gas 8 \\\n  --priority-fee-per-gas 0 \\\n  transfer \\\n    --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A \\\n    --amount 100\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n  --nonce 0 `\n  --gas-limit 100000 `\n  --max-base-fee-per-gas 8 `\n  --priority-fee-per-gas 0 `\n  transfer `\n    --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A `\n    --amount 100\n</code></pre> <p>Example - Deploy contract and save to designated file <code>deposit-tx.json</code>:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--destination ~/Documents/deposit-tx.json \\\n--nonce 0 \\\n--gas-limit 100000 \\\n--max-base-fee-per-gas 8 \\\n--priority-fee-per-gas 0 \\\ndeploy \\\n  --contract-code /home/document/code.wasm \\\n  --cbi-version 0\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--destination ~/Documents/deposit-tx.json `\n--nonce 0 `\n--gas-limit 100000 `\n--max-base-fee-per-gas 8 `\n--priority-fee-per-gas 0 `\ndeploy `\n  --contract-code /home/document/code.wasm `\n  --cbi-version 0\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/#append-command-to-existing-file","title":"Append Command to Existing File","text":"<p>As explained in the beginning of Transaction section, Transaction in ParallelChain protocol accepts sequence of commands. But you may find that <code>transaction create</code> in previous section only support a single Command in Transaction. </p> <p>If you want to support multiple Commands, use the following command with the subcommand. This appends a <code>Command</code> element to the back of the command array in Transaction. Please note that commands in array will be executed in sequential order.</p> <p>Example:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction append \\\n--file ~/Documents/deposit-tx.json \\\ntransfer \\\n  --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A \\\n  --amount 100\n</code></pre> <pre><code>./pchain_client.exe transaction append `\n--file ~/Documents/deposit-tx.json `\ntransfer `\n  --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A `\n  --amount 100\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/pchain_cli/transaction/#submit-transaction-to-parallelchain","title":"Submit Transaction to ParallelChain","text":"<p>After preparing the transaction json file, you can now submit the transaction with keypair.</p> <p>Example:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction submit \\\n--file &lt;FILE&gt; \\\n--keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction submit `\n--file &lt;FILE&gt; `\n--keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <p>You will get a response like the following example if the transaction is accepted by your provider. <pre><code>{\n  \"API Response:\": \"Your Transaction has been received.\",\n  \"Command(s):\": [\n    {\n      \"Deploy\":\n      {\n        \"cbi_version\": 0,\n        \"contract\": \"&lt;contract in 53476 bytes&gt;\"\n      }\n    }\n  ],\n  \"Contract Address:\": \"EH-0Im5Pb5mZQumIP6AAxyqTU7fBWQsNfLdGfaBh8AE\",\n  \"Signature:\": \"DdRr2l-f3SwWtQP7M5JKdOUEvIb-th2mBrV1z06dkvB2rpp0qKQZwBBzJBh8czCqplUsmzSlSjPNrvOQbx2jAA\",\n  \"Transaction Hash:\": \"POikFlLT8sVuVt3RHJvxmzPKP8dfvi55TrME6Muc80I\"\n}\n</code></pre></p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"toolings/rpc/block_rpc/","title":"ParallelChain RPC API","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#block-rpcs","title":"Block RPCs","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#block","title":"block","text":"<p>Get a block by its block hash.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#request","title":"Request","text":"<pre><code>struct BlockRequest {\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#response","title":"Response","text":"<pre><code>struct BlockResponse {\n    block: Option&lt;Block&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#block_header","title":"block_header","text":"<p>Get a block header by its block hash.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#request_1","title":"Request","text":"<pre><code>struct BlockHeaderRequest {\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#response_1","title":"Response","text":"<pre><code>struct BlockHeaderResponse {\n    block_header: Option&lt;BlockHeader&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#block_height_by_hash","title":"block_height_by_hash","text":"<p>Get the height of the block with a given block hash. </p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#request_2","title":"Request","text":"<pre><code>struct BlockHeightByHashRequest {\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#response_2","title":"Response","text":"<pre><code>struct BlockHeightByHashResponse {\n    block_hash: CryptoHash,\n    block_height: Option&lt;BlockHeight&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#block_hash_by_height","title":"block_hash_by_height","text":"<p>Get the hash of a block at a given height.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#request_3","title":"Request","text":"<pre><code>struct BlockHashByHeightRequest {\n    block_height: BlockHeight,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#response_3","title":"Response","text":"<pre><code>struct BlockHashByHeightResponse {\n    block_height: BlockHeight,\n    block_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#highest_committed_block","title":"highest_committed_block","text":"<p>Get the hash of the highest committed block. </p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#request_4","title":"Request","text":"<p>None.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/block_rpc/#response_4","title":"Response","text":"<pre><code>struct HighestCommittedBlockResponse {\n    block_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/introduction/","title":"ParallelChain RPC API","text":"<p>This document specifies the ParallelChain RPC API, an HTTP API that Fullnodes make available to clients. </p> <p>We spell out the general properties of the API, and then list the available RPCs. With each RPC, we define a request structure and a response structure. </p> <p>For readability, we categorize RPCs into transaction-related RPCs, block-related RPCs, and state-related RPCs.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/introduction/#general-properties","title":"General Properties","text":"<ol> <li>Procedures are reachable over HTTP at a URL suffixed by the procedure\u2019s name.</li> <li>All HTTP requests should be POST.</li> <li>Request and response structures are serialized using Borsh and carried in HTTP message bodies. </li> <li>Procedures are \u201cstrongly typed\u201d. If a procedure receives a request that cannot be deserialized, it will send back a response with an empty body and a Bad Request (400) status code.</li> <li>Conversely, if a procedure receives a request that can be deserialized, the response it sends back must have an OK (200) status code. This is even if, for example, something was \u201cnot found\u201d (e.g., a block was not found with a specified hash), or a transaction was not added to the mempool. Error statuses are reported in response structures.</li> <li>All requests and OK responses should have a content-type of \"application/octet-stream\". This is so that we can easily extend the RPC API in the future to support other serialization schemes, e.g., JSON using \"application/json\".</li> </ol>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/","title":"ParallelChain RPC API","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#state-rpcs","title":"State RPCs","text":"<p>State RPCs return multiple entities in the world state in a single response. This allows clients to get a consistent snapshot of the world state in a single call.</p> <p>Every response structure includes the hash of the highest committed block when the snapshot is taken.</p> <p>Some of the following RPCs' response structures reference types unique to this document. These are specified in types referenced in state RPC responses.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#state","title":"state","text":"<p>Get the state of a set of accounts (optionally including their contract code), and/or a set of storage tuples.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request","title":"Request","text":"<pre><code>struct StateRequest {\n    accounts: HashSet&lt;PublicAddress&gt;,\n    include_contracts: bool,\n    storage_keys: HashMap&lt;PublicAddress, HashSet&lt;Vec&lt;u8&gt;&gt;&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response","title":"Response","text":"<pre><code>struct StateResponse {\n    accounts: HashMap&lt;PublicAddress, Account&gt;,\n    storage_tuples: HashMap&lt;PublicAddress, HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#validator_sets","title":"validator_sets","text":"<p>Get the previous, current, and next validator sets, optionally including the stakes delegated to them.  </p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request_1","title":"Request","text":"<pre><code>struct ValidatorSetsRequest {\n    include_prev: bool,\n    include_prev_delegators: bool,\n    include_curr: bool,\n    include_curr_delegators: bool,\n    include_next: bool,\n    include_next_delegators: bool,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response_1","title":"Response","text":"<pre><code>struct ValidatorSetsResponse {\n    // The inner Option is None if we are at Epoch 0.\n    prev_validator_set: Option&lt;Option&lt;ValidatorSet&gt;&gt;,\n    curr_validator_set: Option&lt;ValidatorSet&gt;,\n    next_validator_set: Option&lt;ValidatorSet&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#pools","title":"pools","text":"<p>Get a set of pools.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request_2","title":"Request","text":"<pre><code>struct PoolsRequest {\n    operators: HashSet&lt;Operator&gt;,\n    include_stakes: bool,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response_2","title":"Response","text":"<pre><code>struct PoolsResponse {\n    pools: HashMap&lt;Operator, Option&lt;Pool&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#deposits","title":"deposits","text":"<p>Get a set of deposits.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request_3","title":"Request","text":"<pre><code>struct DepositsRequest {\n    stakes: HashSet&lt;(Operator, Owner)&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response_3","title":"Response","text":"<pre><code>struct DepositsResponse {\n    deposits: HashMap&lt;(Operator, Owner), Option&lt;Deposit&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#stakes","title":"stakes","text":"<p>Get a set of deposits.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request_4","title":"Request","text":"<pre><code>struct StakesRequest {\n    stakes: HashSet&lt;(Operator, Owner)&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response_4","title":"Response","text":"<pre><code>struct StakesResponse {\n    stakes: HashMap&lt;(Operator, Owner), Option&lt;Stake&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#view","title":"view","text":"<p>Call a method in a contract in a read-only way.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#request_5","title":"Request","text":"<pre><code>struct ViewRequest {\n    target: PublicAddress,\n    method: Vec&lt;u8&gt;,\n    arguments: Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#response_5","title":"Response","text":"<pre><code>struct ViewResponse {\n    receipt: CommandReceipt,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#types-referenced-in-state-rpc-responses","title":"Types Referenced in State RPC Responses","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#account-related-types","title":"Account-related types","text":"<pre><code>enum Account {\n    WithContract(AccountWithContract),\n    WithoutContract(AccountWithoutContract),\n}\n\nstruct AccountWithContract {\n    nonce: Nonce,\n    balance: Balance,\n    contract: Option&lt;Vec&lt;u8&gt;&gt;, \n    cbi_version: Option&lt;CBIVersion&gt;,\n    storage_hash: Option&lt;CryptoHash&gt;,\n}\n\nstruct AccountWithoutContract {\n    nonce: Nonce,\n    balance: Balance,\n    cbi_version: Option&lt;CBIVersion&gt;,\n    storage_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/state_rpc/#staking-related-types","title":"Staking-related types","text":"<pre><code>enum ValidatorSet {\n    WithDelegators(Vec&lt;PoolWithDelegators&gt;),\n    WithoutDelegators(Vec&lt;PoolWithoutDelegators&gt;),\n}\n\ntype Operator = PublicAddress;\ntype Owner = PublicAddress;\n\nstruct PoolWithDelegators {\n    operator: PublicAddress,\n    power: Balance,\n    commission_rate: u8, \n    operator_stake: Option&lt;Stake&gt;,\n    delegated_stakes: Vec&lt;Stake&gt;,\n}\n\nstruct PoolWithoutDelegators {\n    operator: PublicAddress,\n    power: Balance,\n    commission_rate: u8, \n    operator_stake: Stake,\n}\n\nstruct Deposit {\n    owner: PublicAddress,\n    balance: u64,\n    auto_stake_rewards: bool,\n}\n\nstruct Stake {\n    owner: PublicAddress,\n    power: Balance,\n}\n\nenum Pool {\n    WithStakes(PoolWithStakes),\n    WithoutStakes(PoolWithoutStakes),\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/","title":"ParallelChain RPC API","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#transaction-rpcs","title":"Transaction RPCs","text":"","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#submit_transaction","title":"submit_transaction","text":"<p>Submit a transaction to the mempool.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#request","title":"Request","text":"<pre><code>struct SubmitTransactionRequest {\n    transaction: Transaction,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#response","title":"Response","text":"<pre><code>struct SubmitTransactionResponse {\n    error: Option&lt;SubmitTransactionError&gt;,\n}\n</code></pre> <p>Where <code>SubmitTransactionError</code>: <pre><code>enum SubmitTransactionError {\n    UnacceptableNonce,\n    MempoolFull,\n    Other,\n}\n</code></pre></p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#transaction","title":"transaction","text":"<p>Get a transaction and optionally its receipt.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#request_1","title":"Request","text":"<pre><code>struct TransactionRequest {    \n    transaction_hash: CryptoHash,\n    include_receipt: bool,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#response_1","title":"Response","text":"<pre><code>struct TransactionResponse {\n    transaction: Option&lt;Transaction&gt;,\n    receipt: Option&lt;Receipt&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#transaction_position","title":"transaction_position","text":"<p>Find out where a transaction is in the blockchain.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#request_2","title":"Request","text":"<pre><code>struct TransactionPositionRequest {\n    transaction_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#response_2","title":"Response","text":"<pre><code>struct TransactionPositionResponse {\n    transaction_hash: Option&lt;CryptoHash&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#receipt","title":"receipt","text":"<p>Get a transaction's receipt.</p>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#request_3","title":"Request","text":"<pre><code>struct ReceiptRequest {    \n    transaction_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"toolings/rpc/transaction_rpc/#response_3","title":"Response","text":"<pre><code>struct ReceiptResponse {\n    transaction_hash: CryptoHash,\n    receipt: Option&lt;Receipt&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#account","title":"Account","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#block-header","title":"Block Header","text":"<ul> <li>Block</li> </ul>"},{"location":"tags/#cli","title":"CLI","text":"<ul> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> </ul>"},{"location":"tags/#call","title":"Call","text":"<ul> <li>Call Contract</li> </ul>"},{"location":"tags/#consensus","title":"Consensus","text":"<ul> <li>Consensus</li> </ul>"},{"location":"tags/#contract-methods","title":"Contract Methods","text":"<ul> <li>Contract Methods</li> </ul>"},{"location":"tags/#contract-publishing-service","title":"Contract Publishing Service","text":"<ul> <li>Contract Publishing Service</li> </ul>"},{"location":"tags/#cross-contract-call","title":"Cross Contract Call","text":"<ul> <li>Cross Contract Call</li> </ul>"},{"location":"tags/#cryptographic-functions","title":"Cryptographic Functions","text":"<ul> <li>Crypto</li> </ul>"},{"location":"tags/#delegator","title":"Delegator","text":"<ul> <li>Delegators</li> </ul>"},{"location":"tags/#eoa","title":"EOA","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#epoch","title":"Epoch","text":"<ul> <li>Epoch</li> </ul>"},{"location":"tags/#epoch-transition","title":"Epoch Transition","text":"<ul> <li>Epoch</li> </ul>"},{"location":"tags/#exit-status","title":"Exit Status","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#explorer","title":"Explorer","text":"<ul> <li>Explorer</li> </ul>"},{"location":"tags/#gray","title":"Gray","text":"<ul> <li>What is XPLL?</li> </ul>"},{"location":"tags/#log","title":"Log","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#mainnet","title":"Mainnet","text":"<ul> <li>What is ParallelChain?</li> <li>Why Build on ParallelChain?</li> </ul>"},{"location":"tags/#maxbasefeepergas","title":"MaxBaseFeePerGas","text":"<ul> <li>Mempool</li> </ul>"},{"location":"tags/#network-account","title":"Network Account","text":"<ul> <li>Account</li> </ul>"},{"location":"tags/#network-transaction","title":"Network Transaction","text":"<ul> <li>Staking</li> </ul>"},{"location":"tags/#nonce","title":"Nonce","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#prfc","title":"PRFC","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#parallelchain","title":"ParallelChain","text":"<ul> <li>Welcome to the ParallelChain Mainnet Documentation</li> <li>What is ParallelChain?</li> <li>Why Build on ParallelChain?</li> </ul>"},{"location":"tags/#parallelchain-mainnet","title":"ParallelChain Mainnet","text":"<ul> <li>Mainnet</li> </ul>"},{"location":"tags/#parallelchain-rpc-api","title":"ParallelChain RPC API","text":"<ul> <li>Block-related RPC</li> <li>Introduction</li> <li>State-related RPC</li> <li>Transaction-related RPC</li> </ul>"},{"location":"tags/#parallelchain-testnet","title":"ParallelChain Testnet","text":"<ul> <li>Testnet</li> </ul>"},{"location":"tags/#pool","title":"Pool","text":"<ul> <li>Delegators</li> <li>Validators</li> </ul>"},{"location":"tags/#receipt","title":"Receipt","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#requirements","title":"Requirements","text":"<ul> <li>Requirements</li> </ul>"},{"location":"tags/#running-nodes","title":"Running Nodes","text":"<ul> <li>Running a Node</li> </ul>"},{"location":"tags/#rust","title":"Rust","text":"<ul> <li>Develop Contract</li> <li>Install SDK</li> </ul>"},{"location":"tags/#smart-contract","title":"Smart Contract","text":"<ul> <li>PRFC</li> <li>Smart Contract</li> <li>Build Contract</li> <li>Call Contract</li> <li>Deploy Contract</li> <li>Develop Contract</li> <li>Install SDK</li> <li>Introduction</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Crypto</li> <li>Contract Methods</li> <li>Accessing Information About the Blockchain</li> <li>Staking in Contract</li> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#staking","title":"Staking","text":"<ul> <li>Staking</li> <li>Delegators</li> <li>FAQ</li> <li>How does staking work?</li> <li>Validators</li> <li>What is staking?</li> <li>Staking</li> <li>Staking in Contract</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#storage","title":"Storage","text":"<ul> <li>Storage</li> </ul>"},{"location":"tags/#txpll","title":"TXPLL","text":"<ul> <li>What is XPLL?</li> </ul>"},{"location":"tags/#testnet-4","title":"Testnet 4","text":"<ul> <li>Testnet</li> </ul>"},{"location":"tags/#token-standard","title":"Token Standard","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>Introduction</li> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> <li>Block-related RPC</li> <li>Introduction</li> <li>State-related RPC</li> <li>Transaction-related RPC</li> </ul>"},{"location":"tags/#transaction","title":"Transaction","text":"<ul> <li>Transaction, Command and Receipt</li> </ul>"},{"location":"tags/#validator","title":"Validator","text":"<ul> <li>Validators</li> </ul>"},{"location":"tags/#wallet","title":"Wallet","text":"<ul> <li>Wallet</li> </ul>"},{"location":"tags/#world-state","title":"World State","text":"<ul> <li>Storage</li> <li>Contract Storage</li> </ul>"},{"location":"tags/#xpll","title":"XPLL","text":"<ul> <li>Wallet</li> <li>How to get XPLL?</li> <li>What is XPLL?</li> </ul>"},{"location":"tags/#account_1","title":"account","text":"<ul> <li>Create Account</li> </ul>"},{"location":"tags/#explorer_1","title":"explorer","text":"<ul> <li>Prepare Environment</li> <li>Prepare Environment</li> </ul>"},{"location":"tags/#faucet","title":"faucet","text":"<ul> <li>Create Account</li> </ul>"},{"location":"tags/#gas","title":"gas","text":"<ul> <li>Gas</li> </ul>"},{"location":"tags/#hotstuffrs","title":"hotstuff.rs","text":"<ul> <li>Consensus</li> </ul>"},{"location":"tags/#internal-transaction","title":"internal transaction","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#mainnet_1","title":"mainnet","text":"<ul> <li>Create Account</li> <li>Prepare Environment</li> <li>Transfer Tokens</li> <li>Prepare Environment</li> <li>Transferring Balance</li> </ul>"},{"location":"tags/#mempool","title":"mempool","text":"<ul> <li>Mempool</li> </ul>"},{"location":"tags/#parallelchain-sdk","title":"parallelchain sdk","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#pchain-cli-rust","title":"pchain-cli-rust","text":"<ul> <li>pchain-cli-rust</li> <li>Install and Setup</li> <li>Introduction</li> <li>Manage Account</li> <li>Query</li> <li>Smart Contract</li> <li>Create Transaction</li> </ul>"},{"location":"tags/#pchain-client","title":"pchain-client","text":"<ul> <li>Create Account</li> <li>Installation</li> <li>Prepare Environment</li> <li>Staking</li> <li>Transfer Tokens</li> <li>Call Contract</li> <li>Deploy Contract</li> </ul>"},{"location":"tags/#pchain-compile","title":"pchain-compile","text":"<ul> <li>Contract Publishing Service</li> <li>Build Contract</li> </ul>"},{"location":"tags/#pchain-sdk","title":"pchain-sdk","text":"<ul> <li>Build Contract</li> <li>Develop Contract</li> <li>Install SDK</li> <li>Introduction</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Crypto</li> <li>Contract Methods</li> <li>Accessing Information About the Blockchain</li> <li>Staking in Contract</li> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"},{"location":"tags/#smart-contract_1","title":"smart contract","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#testnet","title":"testnet","text":"<ul> <li>Prepare Environment</li> <li>Transfer Tokens</li> <li>Prepare Environment</li> </ul>"},{"location":"tags/#testnet-4_1","title":"testnet 4","text":"<ul> <li>Create Account</li> <li>Transferring Balance</li> </ul>"},{"location":"tags/#transaction_1","title":"transaction","text":"<ul> <li>Accessing Information About the Blockchain</li> </ul>"},{"location":"tags/#tutorial","title":"tutorial","text":"<ul> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 6</li> </ul>"}]}